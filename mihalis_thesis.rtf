{\rtf1\ansi\uc1\deff0\deflang1024
{\fonttbl{\f0\fnil\fcharset0 Times New Roman;}
{\f1\fnil\fcharset0 Arial;}
{\f2\fnil\fcharset0 Arial;}
{\f3\fnil\fcharset0 Courier New;}
{\f4\fnil\fcharset0 Zapf Chancery;}
{\f5\fnil\fcharset0 STIXGeneral;}
{\f6\fnil\fcharset0 MS Gothic;}
}
{\colortbl;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
}
{\stylesheet
{\s0\qj\widctlpar\f0\fs24 \snext0 Normal;}
{\cs10 \additive\ssemihidden Default Paragraph Font;}
{\s1\qc\sb240\sa120\keepn\f0\b\fs40 \sbasedon0\snext0 Part;}
{\s2\ql\sb240\sa120\keepn\f0\b\fs40 \sbasedon0\snext0 heading 1;}
{\s3\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext0 heading 2;}
{\s4\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext0 heading 3;}
{\s5\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 4;}
{\s6\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 5;}
{\s7\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 6;}
{\s8\qr\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext8 rightpar;}
{\s9\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext9 centerpar;}
{\s10\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext10 leftpar;}
{\s11\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equation;}
{\s12\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationNum;}
{\s13\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationAlign;}
{\s14\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationAlignNum;}
{\s15\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationArray;}
{\s16\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationArrayNum;}
{\s17\ql\sb120\sa120\keep\widctlpar\f0\fs20 \sbasedon0\snext0 theorem;}
{\s18\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 bitmapCenter;}
{\s20\qc\sb240\sa240\b\f0\fs36 \sbasedon0\snext21 Title;}
{\s21\qc\sa120\f0\fs24 \sbasedon0\snext0 author;}
{\s22\ql\tqc\tx4536\tqr\tx9072\f0\fs20 \sbasedon0\snext22 footer;}
{\s23\ql\tqc\tx4536\tqr\tx9072\f0\fs20 \sbasedon0\snext23 header;}
{\s30\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 caption;}
{\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext0 Figure;}
{\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext32 Table;}
{\s33\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext33 Tabular;}
{\s34\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext34 Tabbing;}
{\s35\qj\li1024\ri1024\fi340\widctlpar\f0\fs20 \sbasedon0\snext35 Quote;}
{\s38\ql\widctlpar\f3\fs24 \snext38 verbatim;}
{\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20 \sbasedon0\snext46 List;}
{\s47\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20 \sbasedon0\snext47 List 1;}
{\s50\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 latex picture;}
{\s51\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 subfigure;}
{\s61\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext62 bibheading;}
{\s62\ql\fi-567\li567\sb0\sa0\f0\fs20 \sbasedon0\snext62 bibitem;}
{\s64\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20 \sbasedon0\snext64 endnotes;}
{\s65\ql\fi-113\li397\lin397\f0\fs24 \sbasedon0\snext65 footnote text;}
{\s66\qj\fi-170\li454\lin454\f0\fs24 \sbasedon0\snext66 endnote text;}
{\cs62\super \additive\sbasedon10 footnote reference;}
{\cs63\super \additive\sbasedon10 endnote reference;}
{\s67\ql\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext67 acronym;}
{\s70\qc\sa120\b\f0\fs24 \sbasedon0\snext71 abstract title;}
{\s71\qj\li1024\ri1024\fi340\widctlpar\f0\fs24 \sbasedon0\snext0 abstract;}
{\s80\ql\sb240\sa120\keepn\f0\b\fs20 \sbasedon0\snext0 contents_heading;}
{\s81\ql\li425\tqr\tldot\tx8222\sb240\sa60\keepn\f0\fs24\b \sbasedon0\snext82 toc 1;}
{\s82\ql\li512\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext83 toc 2;}
{\s83\ql\li1024\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext84 toc 3;}
{\s84\ql\li1536\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext85 toc 4;}
{\s85\ql\li2048\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext86 toc 5;}
{\s86\ql\li2560\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext86 toc 6;}
}
{\info
{\title Original file was mihalis_thesis.tex}
{\doccomm Created using latex2rtf 2.3.16 r1254 (released May 12 2017) on Mon May 22 11:13:21 2017
}
}
{\footer\pard\plain\f0\fs24\qc\chpgn\par}
\paperw12280\paperh15900\margl2680\margr2700\margt2540\margb1760\pgnstart0\widowctrl\qj\ftnbj\f0\aftnnar
{\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \fs20 {Yiorgos Makris}  \par
\pard\plain\s20\qc\sb240\sa240\b\f0\fs36\sl240\slmult1 \fi360 Enhancing modern microprocessor resiliency through workload-cognizant, cross-layer, error impact analysis\par
\pard\plain\s21\qc\sa120\f0\fs24\sl240\slmult1 \fi360 Michail Maniatakos\par
\pard\plain\s21\qc\sa120\f0\fs24\sl240\slmult1 \fi360 December 2012\par
{\pard\plain\s70\qc\sa120\b\f0\fs24\sl240\slmult1 \fi360 Abstract\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li1024\ri1024\fi360 \par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li1024\ri1024\fi360 Microprocessors are ubiquitously deployed in applications ranging from commodity devices to mission critical systems. Inevitably, frequent occurrence of malfunctions is a fact of life, instigated either by permanent failure causes (e.g., manufacturing defects, environmental wear-&-tear) or by transient error sources (e.g., cosmic radiation). As microprocessors constitute the most complex integrated circuits, exhaustively analyzing their design and implementation in order to identify weaknesses that may jeopardize resilience is intractable. As the majority of the microprocessor revenue arises from performance, allocating area, power, and design time resources to non-performance related features, such as resilience, is an uphill battle.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li1024\ri1024\fi360 Toward addressing these challenges, this dissertation centers around the exploration of the various trade-offs involved in developing cost-effective resilience features, which can be realistically incorporated in modern microprocessors. Specifically, a workload-cognizant, cross-layer analysis approach is explored, in order to (i) understand the impact of various malfunctions on robust operation, (ii) develop cost-effective error detection/correction methods for robustness-sensitive structures, such as microprocessor controllers, (iii) assess weak spots, and (iv) drive parity selection methods for in-core memory arrays. The ability to reason across layers, from transistors to architecture and from events to instructions, serves as the key to developing industrially-relevant, resilience enhancing methodologies.\par
}\pard\plain\s80\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0  Contents\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \par
{\field{\*\fldinst TOC \\o "1-3" }{\fldrslt }}
\page
\pard\plain\s80\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb60 \fi0  List of Figures\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \par
{\field{\*\fldinst TOC \\f f }{\fldrslt }}
\page
\pard\plain\s80\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb60 \fi0  List of Tables\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \par
{\field{\*\fldinst TOC \\f t }{\fldrslt }}
\page
\pard\plain\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb60 \fi0 Chapter\par
\pard\plain\s2\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb240 \fi0 Acknowledgments\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0 First, I would like to thank my advisor, Yiorgos Makris, for his continuous support and great guidance all these 5 years of my PhD. I would also like to thank my Greek friends in New Haven, Argyro Katsika, Antonis Stampoulis, Thanasis Bamis, Maria Svoronou, Dimitris Lymperopoulos, Maria Vasileiou, Palmyra Geraki, Dimitris Zattas, Chris Zattas, Petros Bregiannis, Tasos Gogakos, Nikos Aggelopoulos, Aryestis Vlahakis, Ifigeneia Derekli, Stefania Panousi, Natasa Sotiropoulou, Kostas Arkolakis and Theodoros Rampias for making New Haven home away from home. Furthermore, I would like to acknowledge my international friends at Yale, Maha El Sayed, Al Starr, Marisa Rubio, and my friends in California, Billy Sladek, Kostas Menychtas, Dan Tu, Jason Weber, James Hanna and Sandeep Gupta for broadening my perspective about the world. Also, I would like to thank my labmates Nathan Kupp, Dzmitry Maliuk, Yier Jin and Naghmeh Karimi for their help and support during the PhD process. \par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 And last, but not least, I would like to thank my family (my parents and my older brother) and all my friends back home, for the confidence and trust they had in me, in every step I took all these years. \par
\pard\plain\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \fi0 Chapter 1\par
\pard\plain\s2\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb240 \fi0 Introduction\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 1  Motivation\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Microprocessors are ubiquitously deployed in applications ranging from commodity devices to mission critical systems, and while malfunctions in the former may cause no harm other than inconvenience, the slightest malfunction in the latter may have catastrophic consequences. \par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 The pace of business is accelerating around the globe, as leading companies in computation-intensive industries, such as financial trading, manufacturing and retail, move toward a real-time business model in which transactions and information sharing are near instantaneous. This transition is putting increasing demands on the performance, capacity, availability and agility of underlying IT infrastructure. As process timelines are compressed from weeks or days, to hours, minutes or even seconds, the cost of downtime skyrockets. The average downtime cost for brokerage operations can reach $675M/hour 
[{\field{\*\fldinst{\lang1024 REF BIB_hennessy2011computer \\* MERGEFORMAT }}{\fldrslt{hennessy2011computer}}}
]. Even in the case of consumer electronics, the estimated downtime cost per hour is $1M. This cost includes unavailability of services, loss of consumer confidence in the company etc. \par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Besides financial or commercial applications, microprocessors are extensively employed in mission critical applications. These application include medical devices or space applications. Ensuring resilience of the deployed microprocessors is paramount, as human lives depend on the proper function of electronics.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 In the recent years, there are several examples of severe electronics failures: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The Therac-25 radiation therapy machine was directly responsible for at least five patient deaths in the 1980s when it administered excessive quantities of X-rays. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The Phobos-Grunt probe to Mars stopped responding soon after its launch and eventually crashed over the Pacific ocean. Reportedly, the reason for the crash was a soft-error affecting its electronics. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
NASA\rquote s Kepler Mission, launched on March 7, 2009, entered safe mode on June 15 and July 2, triggered by a processor reset. The root cause was a single event upset of a circuit in the processor. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The Sandy Bridge chipset problems caused Intel to initiate a billion-dollar chipset recall. The issue is a circuit design problem resulting in a gradual degradation over time of SATA connectivity on the affected ports, manifesting itself as high bit-error rates on those ports and eventually as total device disconnects. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi360 Aggressive technology advancements and continuous shrinking of modern process geometries enable multiple sources of errors to jeopardize the reliability of modern microprocessor designs. Among them, soft (or transient) errors due to neutron particles from cosmic rays and alpha particles from packaging material (
[{\field{\*\fldinst{\lang1024 REF BIB_normand1996single \\* MERGEFORMAT }}{\fldrslt{normand1996single}}}, {\field{\*\fldinst{\lang1024 REF BIB_constantinescu2003trends \\* MERGEFORMAT }}{\fldrslt{constantinescu2003trends}}}
]) have resurfaced as a key point of interest. Besides soft errors, uncertainties caused by process, voltage and temperature variations have also become a serious concern, forcing designers to use pessimistic design margins. As Moore\rquote s law projects exponential increase in transistor counts, this also implies an exponential increase in error rates of unprotected microprocessors. Typical predictions of FIT (Failures in Time, one FIT specifies one failure in billion hours) vary between 0.001 - 0.01 per bit, at sea level 
[{\field{\*\fldinst{\lang1024 REF BIB_normand1996single \\* MERGEFORMAT }}{\fldrslt{normand1996single}}}
]. Given that, for example the latest Intel Core includes more than a billion transistors, microprocessor protection is now a necessity. Finally, aggressive techniques to decrease the power consumption of the microprocessor, such as clock gating, workload adaptation and lower operating voltages, introduce thermal hotspots, which in turn further increase the vulnerability of the processor to errors.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 As microprocessors constitute the most complex integrated circuits, exhaustively analyzing their design and implementation in order to identify weaknesses that may jeopardize robustness is intractable. Design size, limited availability of such models in public, increasing area of control logic as well as power limitations pose difficult challenges in the objective of enhancing microprocessor resilience. Furthermore, as processes feature sizes continue to shrink, it has become more likely that adjacent elements may also be affected by a single event 
[{\field{\*\fldinst{\lang1024 REF BIB_criswell1984single \\* MERGEFORMAT }}{\fldrslt{criswell1984single}}}
], thereby causing a multiple-bit upset (MBU). Hence, allocating area, power, and design time resources to non-performance related features, such as robustness, is an uphill battle. Cost-effective solutions, along with a mechanism to understand and definitively quantify the return on investment of robustness-enhancing features, are necessary for ensuring microprocessor resiliency.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 2  Workload-cognizant, cross-layer impact analysis approach\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Toward addressing these challenges, this thesis centers around the exploration of the various trade-offs involved in developing cost-effective robustness features, which can be realistically incorporated in modern microprocessors, as presented in Fig. {\field{\*\fldinst{\lang1024 REF BMfOutline \\* MERGEFORMAT }}{\fldrslt{1.1}}}. Specifically, the presented dissertation research explores a workload-cognizant, cross-layer analysis approach to: \par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 1.\tab
Understand the impact of various malfunctions on robust operation, \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 2.\tab
Develop cost-effective error detection/correction methods for robustness-sensitive structures, such as microprocessor controllers, \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 3.\tab
Assess weak spots and prioritize robustness resource allocation, \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 4.\tab
Protect in-core memory arrays against single and multiple bit errors,\par
}{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb300 \fi360 \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfOutline}1{\*\bkmkend BMfOutline}: Doctoral thesis outline}{\field{\*\fldinst TC "1 Doctoral thesis outline" \\f f}{\fldrslt }}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 The ability to reason across layers, from transistors to architecture and from events to instructions, serves as the key to developing resiliency enhancing methodologies which extend beyond academic curiosity and become industrially relevant. Consequently, the following main contributions have been successfully demonstrated not only on academic microprocessor models (e.g., IVM) but also on commercial microprocessors (e.g., SUN SPARC, Intel Core). \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.1  Cross-layer impact analysis methodology\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The cornerstone of this doctoral research is a methodology for studying the correlation between low-level faults in a modern microprocessor and their instruction-level impact on the execution of typical workload. Such information is immensely useful in appropriately allocating resources to enhance error/fault resilience through concurrent error detection/correction methods. To this end, an extensive fault simulation infrastructure is developed, which enables injection of stuck-at faults and transient errors of arbitrary starting time and duration, both at the Register Transfer Level and at the Gate Level, as well as cost-effective simulation and classification of their repercussions into various instruction-level error types. As a test vehicle for this study, a superscalar, out-of-order Alpha 21264 microprocessor is employed, with SPEC2000 benchmarks executed as its workload. Extensive fault injection campaigns in key control modules of this microprocessor revealed valuable observations regarding the distribution of low-level faults into the instruction-level error types that they cause. For example, most low-level faults affect the issue or retirement cycle of an instruction, while a very small number of faults affect the retirement order of the instructions. The ability to obtain such information quickly and accurately is crucial towards commensurately allocating resources for ensuring microprocessor robustness in a cost-effective manner.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2  Error detection and correction for microprocessor control logic\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The second chapter of this doctoral thesis focuses on developing concurrent error detection (CED) methods for robustness-sensitive structures of modern microprocessors, such as the control logic. Specifically, a Concurrent Error Detection (CED) scheme for (i) the Scheduler of a modern microprocessor and (ii) the control logic of contemporary floating-point units (FPUs) is developed. The former is based on monitoring a set of invariant properties, violation of which signifies the occurrence of an error. The novelty of the presented solution stems from the workload-cognizant way in which these invariant properties are selected, based on the aforementioned cross-layer impact analysis, so that they leverage the application-level error masking inherent in program execution. At a hardware cost of only 3% of the Alpha 21264 core, the corresponding CED scheme detects over 85% of the Scheduler faults that affect the architectural state of the microprocessor. Furthermore, over 99.5% of these faults are detected before they corrupt the architectural state, implying that the developed technique detects the errors very close to the source. The latter is based on the observation that control logic errors lead to extensive datapath corruption and affect, with high probability the exponent part of the IEEE-754 floating point representation. Indeed, experimental results on the SPARC T1 FPU show that, the developed method incurs an area overhead of only 5.8%, compared to the 17.9% of control duplication, yet still achieves detection of over 93% of transient errors in the FPU control logic. Moreover, the proposed method offers the ancillary benefit of also detecting 98.1% of the datapath errors that affect the exponent, which cannot be detected via duplication of control logic.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.3  Weak-spot assessment and robustness resource allocation prioritization\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 A third key contribution of the presented doctoral research is a novel method for assessing the susceptibility of modern microprocessor state elements to failures in the field of operation, which is called Global Signal Vulnerability (GSV) analysis. In order to effectively allocate resources for enhancing robustness, GSV analysis takes into account the high degree of architectural masking exhibited in modern microprocessors and ranks state elements accordingly. The novelty of this method lies in the way this ranking is computed. GSV analysis operates either at the Register Transfer (RT-) or at the Gate-Level, offering increased accuracy in comparison to methods which compute the architectural vulnerability factor (AVF) of registers through high-level simulations on performance models. Moreover, it does not rely on extensive Statistical Fault Injection (SFI) campaigns and lengthy executions of workloads to completion in RT- or Gate-Level designs, which would make such analysis prohibitive. Instead, it monitors the behavior of key global microprocessor signals in response to a progressive stuck-at fault injection method during partial workload execution. Experimentation with the Scheduler and Reorder Buffer modules of both an Alpha 21264 microprocessor and a modern Intel microprocessor (Intel Core) corroborates that GSV analysis generates a near-optimal ranking, yet is several orders of magnitude faster than existing RT- or Gate-Level approaches.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.4  Parity selection for in-core memory arrays protection\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 This chapter presents an AVF-driven parity selection method for protecting modern microprocessor in-core memory arrays against MBUs. As MBUs constitute more than 50% of the upsets in latest technologies, error correcting codes or physical interleaving are typically employed to effectively protect out-of-core memory structures, such as caches. However, such methods are not applicable to high-performance in-core arrays, due to computational complexity, high delay and area overhead. To this end, parity is revisited as an effective mechanism to detect errors and pipeline flushing and checkpointing is used for correction. As the optimal parity tree construction for MBU detection is a computationally complex problem, an integer-linear-program (ILP) formulation is used. Experimental results on Alpha 21264 and Intel P6 in-core memory arrays demonstrate that optimal parity tree selection can achieve great vulnerability reduction, even when a small number of bits are added to the parity trees. Furthermore, while the presence of 2 parity trees offers a vulnerability reduction of more than 50% over a single parity tree, adding more parity trees does not contribute significantly to the total MBU resiliency enhancement.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Furthermore, after the formulation of the parity selection problem as an ILP, this chapter also presents a cost-effective method for enhancing in-core memory array resiliency, called Vulnerability-based Interleaving (VBI). VBI physically disperses bit-lines based on their vulnerability factor and applies selective parity to these lines. Thereby, VBI aims to ensure that an MBU will affect at most one critical bit-field, so that the selective parity will detect the error and a subsequent pipeline flush will remove its effects. Experimental results employing simulation of realistic MBU fault models on the instruction queue of the Alpha 21264 microprocessor in a 65nm process, demonstrate that a 30% selective parity protection of VBI-arranged bit-lines reduces vulnerability by 94%.\par
\page
\pard\plain\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \fi0 Chapter {\*\bkmkstart BMsC2}2{\*\bkmkend BMsC2}\par
\pard\plain\s2\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb240 \fi0 Impact analysis methodology\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 {\*\bkmkstart BMsC2Intro}1{\*\bkmkend BMsC2Intro}  Introduction\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 While a plethora of microprocessor resiliency enhancement solutions have been developed in the past, blindly applying them across the board is not only prohibitive in terms of cost but also unnecessary in terms of the attained coverage. Indeed, not all faults incur the same level of criticality and not all protection mechanisms contribute equally to the overall robustness of a design. Therefore, methods which analyze the relative importance of potential faults and the relative effectiveness of candidate countermeasures are invaluable for developing cost-effective solutions.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Modern microprocessors, in particular, exhibit an inherent effectiveness in suppressing a significant percentage of faults and preventing them from interfering with correct program execution (i.e. application-level masking). In other words, the probability that a fault will adversely impact the typical workload of a microprocessor varies greatly, depending on the frequency with which the corresponding hardware is used and the complexity of the control conditions necessary to propagate its effect to the architectural state of the microprocessor. Hence, application-level masking presents a great opportunity for developing cost-effective CED methods by identifying and targeting the most critical faults.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 To this end, the research described in this chapter seeks to provide the ability to assess the relative importance of low-level faults (i.e. faults in the RT- or Gate-Level description) in the control logic of a modern high-performance microprocessor, as gauged by their impact on the execution of typical programs. Specifically, the contributions of this chapter include: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
An extensive infrastructure built around a modern microprocessor model, enabling simulation of low-level faults and analysis of their instruction-level impact during execution of typical workload. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
An instruction-level error model, reflecting the key aspects of instruction execution, to which the impact of low-level faults is mapped. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
A comprehensive set of fault simulation results demonstrating the correlation between low-level faults in a modern microprocessor controller and the instruction-level errors that they incur. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi360 The starting point for developing the aforementioned infrastructure is a public-domain high-performance microprocessor, which is briefly discussed in Section {\field{\*\fldinst{\lang1024 REF BMsC2Existing \\* MERGEFORMAT }}{\fldrslt{2.2}}}. Section {\field{\*\fldinst{\lang1024 REF BMsC2Developed \\* MERGEFORMAT }}{\fldrslt{2.3}}} presents the various components and capabilities of the developed infrastructure, along with its utilization flow for fault injection, simulation and impact analysis. The proposed instruction-level error model, which is used to capture the impact of low-level faults on program execution is introduced in Section {\field{\*\fldinst{\lang1024 REF BMsC2ILEs \\* MERGEFORMAT }}{\fldrslt{2.4}}}. Extensive fault simulation campaigns using the developed infrastructure are presented in Section {\field{\*\fldinst{\lang1024 REF BMsC2Experiments \\* MERGEFORMAT }}{\fldrslt{2.5}}}, along with a detailed analysis of the obtained results and a discussion of their significance in guiding the development of cost-effective CED methods.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsC2Existing}2{\*\bkmkend BMsC2Existing}  Test Vehicle\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 We start by briefly presenting the microprocessor that we will use as the test vehicle in our investigation. We discuss the capabilities of the simulation infrastructure that has been previously developed by other researchers around this microprocessor, we pinpoint its limitations and we identify its components that need to be enhanced in order to support our study.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC2MModel}2.1{\*\bkmkend BMsC2MModel}  Microprocessor Model and Functional Simulator\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Since the focus of this work is the cross-correlation between control logic faults and instruction level errors in modern microprocessors, the underlying test vehicle should incorporate as many of the state-of-the-art architectural features as possible. Among the very limited number of such test-cases available in the public domain, we chose to work with a Verilog implementation of an Alpha-like microprocessor, called IVM (Illinois Verilog Model) 
[{\field{\*\fldinst{\lang1024 REF BIB_WMP07 \\* MERGEFORMAT }}{\fldrslt{WMP07}}}
]. IVM implements a subset of the instruction set of the Alpha 21264 microprocessor, and is rich in architectural features including superscalar, out-of-order execution, dynamically scheduled pipeline, hybrid branch prediction and speculative instruction execution. IVM can have up to 132 instructions in-flight through its 12-stage pipeline, supported by a dynamic scheduler of 32 entries and 6 functional units. The complexity of IVM reflects most of the features of modern, high-performance microprocessors; thus, it enables a realistic investigation of the instruction-level impact of control logic faults in such microprocessors. Besides the Verilog implementation, a functional simulator that can be used in conjunction with the IVM processor model through the Verilog Procedural Interface (VPI) also exists. This functional simulator supports the full set of the Alpha 21264 processor and is part of the SimpleScalar tool suite 
[{\field{\*\fldinst{\lang1024 REF BIB_BuAu97 \\* MERGEFORMAT }}{\fldrslt{BuAu97}}}
].\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2  Capabilities and Limitations\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 IVM was developed and used to study the impact of single-event transient errors 
[{\field{\*\fldinst{\lang1024 REF BIB_WMP07 \\* MERGEFORMAT }}{\fldrslt{WMP07}}}, {\field{\*\fldinst{\lang1024 REF BIB_WaPa05 \\* MERGEFORMAT }}{\fldrslt{WaPa05}}}, {\field{\*\fldinst{\lang1024 REF BIB_WQRP04 \\* MERGEFORMAT }}{\fldrslt{WQRP04}}}
], modeled as single register-level bit-flips. Unfortunately, Gate-Level fault simulation cannot be performed; due to certain coding techniques used at the RT-Level model, IVM is not synthesizable. Instead, an approach of stopping the simulation, altering the state of the microprocessor, and then resuming the simulation was employed in these studies. This fault injection approach is effective when studying the impact of single-cycle transient errors, such as those caused by alpha particle strikes. However, it is extremely inefficient for other fault models, such as stuck-at faults or transient errors of longer duration caused by operational marginalities. Indeed, the process of injecting a fault for a clock cycle involves extensive file-system-based interactions and becomes very time consuming if done for more than a few clock cycles. To alleviate this limitation, we enhanced this infrastructure to support efficient injection and simulation for such longer-lasting faults, as we describe in Section {\field{\*\fldinst{\lang1024 REF BMsC2Developed \\* MERGEFORMAT }}{\fldrslt{2.3}}}.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Another key aspect of the existing infrastructure is that both IVM and the functional simulator can execute software compiled for the Alpha microprocessor. This is important, since it allows us to study the impact of faults while the microprocessor is executing a typical workload, thus making our findings more realistic. However, IVM does not support the full instruction set of Alpha; floating point instructions and various system-calls have not been implemented. Therefore, the functional simulator must be used to surmount this limitation, by invoking it whenever such instructions need to be executed. This interaction is enabled through the ability of the functional simulator to load/store the state of the Verilog model and vice-versa at any given clock cycle.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsC2Developed}3{\*\bkmkend BMsC2Developed}  Enhanced Simulation Infrastructure\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 We now proceed to describe the fault simulation enhancements that we added to the aforementioned infrastructure, as well as the pertinent tool-flow that enables our study. We first outline the main capabilities of the enhanced infrastructure, followed by a detailed description of its basic components and a discussion of its utilization.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 3.1  Capabilities\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 We augmented the IVM microprocessor model described in Section {\field{\*\fldinst{\lang1024 REF BMsC2Existing \\* MERGEFORMAT }}{\fldrslt{2.2}}} to provide the following key features: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Workload simulation:} We can simulate software written for the Alpha microprocessor. In our experiments, we use SPEC2000 Integer benchmarks. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Fault injection & simulation:} We can perform fault injection into any register or wire entity of the microprocessor by mutating the model accordingly. Fault injection is controlled by a fault controller module inside the microprocessor. The fault simulation infrastructure supports stuck-at faults and transient errors of used-specified start time and duration. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Trace dumping:} The model can produce traces at the periphery of any module of the microprocessor for any user-specified number of clock cycles. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b State dumping:} At any given clock cycle, we can save all information concerning the machine state, as well as the architectural state of the processor. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Incorporation of Gate-Level modules:} Synthesizable versions of two modules, namely the Scheduler and the ReOrder Buffer (ROB) have been implemented and can substitute their RT-Level counterparts in the microprocessor model. \par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 3.2  Main Components\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb300 \fi0  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2parts}1{\*\bkmkend BMsC2parts}: Infrastructure components and interactions}{\field{\*\fldinst TC "1 Infrastructure components and interactions" \\f f}{\fldrslt }}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 The enhanced fault simulation infrastructure consists of three main parts, as shown in Fig. {\field{\*\fldinst{\lang1024 REF BMsC2parts \\* MERGEFORMAT }}{\fldrslt{2.1}}}: i) supporting tools to control fault injection and the I/O of the simulation procedure, ii) a functional simulator of the Alpha microprocessor, and iii) the augmented version of the microprocessor model, where a Fault Controller module has been added to enable Fault Injection.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 3.2.1  Fault Injection Tools\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The main functionality of the fault injection tools is to provide support to the functional simulator by generating the appropriate files and passing parameters for specific operations (e.g. which fault location to inject, the type of injected fault, etc.), as well as accumulating and reporting the simulation results to the user.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Furthermore, the developed tools can be used to save any trace or state files requested and perform comparisons between golden (fault-free) and faulty model executions. The state files contain information regarding the states of all flip-flops and SRAMs in the microprocessor, including the register file and the main memory. The user can choose to extract any subset of the aforementioned storage elements (e.g. only the architectural register file). Besides state files, we can also log the inputs and the outputs of any given module at specified clock cycles, producing a trace file. This file can then be used to study the impact of faults on individual modules. Furthermore, the trace file provides useful statistics about the activation and usage of the I/O of a module, such as identifying the most frequently used wires, their switching frequency etc.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 3.2.2  Functional Simulator\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The presence of a functional simulator in the flow is essential because it enhances the functionality of the microprocessor model. Since the current version of IVM does not implement floating point operations, system calls and miscellaneous other instructions of the Alpha 21264 processor, these instructions can be executed via the functional simulator, which implements the complete instruction set. The simulation can be switched from the functional simulator to the Verilog model and vice-versa at any given time, using VPI calls. In practice, for the SPEC2000 Integer Benchmarks used in this study, the functional simulator is used to skip the initial system calls, after which the execution continues at the RT-level model of the IVM microprocessor.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Furthermore, the functional simulator enhances the I/O functionality of the Verilog model. Thus, it enables reading of values from files and passing parameters to the Verilog model during transition between states. It can also output the state or traces of the microprocessor model to the file system. These features enable fault injection and analysis as well as trace dumping through the developed simulation infrastructure.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 3.2.3  Microprocessor Model\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The microprocessor model used is IVM, which was briefly described in section {\field{\*\fldinst{\lang1024 REF BMsC2MModel \\* MERGEFORMAT }}{\fldrslt{2.2.1}}}. Since the existing IVM version cannot be synthesized so that gate-level fault injection and simulation can be performed, an alternative way for doing this is required. Even if the complete processor was synthesizable, fault-simulating the entire Gate-Level model would probably be impractical. Hence, we are limited to using RT-Level logic simulation tools, such as Synopsys VCS. This enables simulation of the RT-Level model of the microprocessor while the latter executes actual workload, but it does not offer fault injection capabilities.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 To address this limitation, we mutate the IVM model so as to support RT-Level fault injection. Specifically, a Fault Controller module is added to the microprocessor, controlling the fault injection process. When this module is deactivated, the microprocessor operates normally, as a fault-free circuit. When it is activated, however, it provides an extensive range of options for injecting faults. Since the module is already built in the microprocessor model, consecutive simulations injecting different faults can be executed without recompiling the model, something that would make any reasonably-sized fault simulation experiment computationally prohibitive. Besides the insertion of a new module, each existing module of IVM is also mutated to provide support for the functions of the Fault Controller, as explained in detail in Section {\field{\*\fldinst{\lang1024 REF BMsC2Fault_Inj \\* MERGEFORMAT }}{\fldrslt{2.3.2}}}.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC2Fault_Injection}3.2.4{\*\bkmkend BMsC2Fault_Injection}  Fault Controller\par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb300 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMsC2Fault_Controller}1{\*\bkmkend BMsC2Fault_Controller}: Input/Output interface of fault controller}{\field{\*\fldinst TC "1 Input/Output interface of fault controller" \\f t}{\fldrslt }}\par
{{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrdb\clbrdrt\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrt\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrt\brdrdb\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql {  {\i0\scaps0\b Type}}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Name}}\cell}
{\pard\intbl\qr {{\i0\scaps0\b Bits}}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Input}\cell}
{\pard\intbl\ql {fault_index}\cell}
{\pard\intbl\qr {32}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Input}\cell}
{\pard\intbl\ql {fault_bit_index}\cell}
{\pard\intbl\qr {8}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Input}\cell}
{\pard\intbl\ql {fault_type}\cell}
{\pard\intbl\qr {2}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Input}\cell}
{\pard\intbl\ql {error_cycle_start}\cell}
{\pard\intbl\qr {32}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Input}\cell}
{\pard\intbl\ql {error_cycle_end}\cell}
{\pard\intbl\qr {32}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Output}\cell}
{\pard\intbl\ql {fault_register}\cell}
{\pard\intbl\qr {42}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx3088\clbrdrl\brdrs\clbrdrb\brdrdb\clbrdrr\brdrs\cellx5554\clbrdrl\brdrs\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Output}\cell}
{\pard\intbl\ql {fault_clock}\cell}
{\pard\intbl\qr {1}\cell}
\row}
} \par
}}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 The main component of fault injection is the embedded Fault Controller module, whose list of inputs and outputs is presented in Table {\field{\*\fldinst{\lang1024 REF BMsC2Fault_Controller \\* MERGEFORMAT }}{\fldrslt{2.1}}} and described below: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b0\f3 fault_index:} Specifies the unique identification number (UID) of the entity to be fault-injected. Every entity in the microprocessor is assigned a UID. If the UID is invalid, no entity will be fault-injected. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b0\f3 fault_bit_index:} Specifies the bit index of the UID to be fault-injected. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b0\f3 fault_type:} Specifies the type of the injected fault. Our infrastructure supports stuck-at faults and transient errors. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b0\f3 error_cycle_start:} Specifies the clock cycle at which the fault injection should commence. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b0\f3 error_cycle_end:} Specifies the clock cycle at which the fault injection should terminate. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b0\f3 fault_register:} Outputs all the information that should be passed to the modules (i.e. {\i0\scaps0\b0\f3 fault_index, fault_bit_index, fault_type}). \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b0\f3 fault_clock:} The clock that activates fault injection within the modules. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi360 By manipulating the data stored in the registers, we can perform single-cycle transient error injection, duration-controlled transient-error injection, or stuck-at fault injection. The registered inputs of the Fault Controller are not connected to and do not interact with the microprocessor model; instead, the functional simulator is responsible for setting these registers to the appropriate values. The output of the Fault Controller propagates to all modules of the microprocessor. In addition, the Fault Controller outputs a clock, which specifies whether a fault should be injected. Specifically, when this clock is 1 each module receives a signal indicating that a fault injection should occur, prompting the module to process the outputs of the Fault Controller.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC2Fault_Inj}3.2.5{\*\bkmkend BMsC2Fault_Inj}  Fault Injection\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 During simulation, the Fault Controller is responsible for fault injection. In each clock cycle, we can access one bit of one entity and set it to a specific value, where the entity can be either a register or a wire. We call this procedure {\i Fault Addressing}. When the Fault Controller activates the fault clock, each module compares the broadcasted UID to the UIDs of its internal entities. If a match is found, the module modifies the corresponding bit, as specified by the outputs of the Fault Controller that are sent to the module. This fault injection technique is similar to the \ldblquote parallel saboteurs\rdblquote  injection technique 
[{\field{\*\fldinst{\lang1024 REF BIB_JAROK94 \\* MERGEFORMAT }}{\fldrslt{JAROK94}}}
]. An extensive comparison to existing fault injection approaches can be found in 
[{\field{\*\fldinst{\lang1024 REF BIB_BGBGG08 \\* MERGEFORMAT }}{\fldrslt{BGBGG08}}}
].\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 For a module to be able to respond to Fault Controller functions, it must be mutated accordingly. For this purpose, after assigning a UID to each entity, a piece of code that will enable Fault Addressing within each module must be generated. Moreover, a fault list containing all faults for every bit of each entity must also be generated. Both fault code and fault list generation are performed by internally developed fault injection tools. Depending on whether a module is described as a netlist or as behavioral verilog, the module is mutated differently:\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {\i0\scaps0\b RT-Level Fault Injection:} For behavioral Verilog, injection is performed in every entity defined in the Verilog model. Fig. {\field{\*\fldinst{\lang1024 REF BMsC2RT_inject \\* MERGEFORMAT }}{\fldrslt{2.2}}} presents a simplified diagram of the method, which is capable of injecting either stuck-at faults or transient faults, with user-defined starting and stopping times (dotted, lighter colored lines indicate resources added for fault simulation purposes). Since we operate at the RT-Level model, only entities described in the Verilog model are fault-injected. Each entity is driven by a {\f3 MUX}, which is controlled by the Fault Controller. The {\i fault clock} signal alters the value of the target entity during the active fault injection window. Each entity has a unique ID, so that the Fault Controller can pick the one to be injected in each clock cycle. {\par
\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2RT_inject}2{\*\bkmkend BMsC2RT_inject}: Fault injection in latches of RT-Level model}{\field{\*\fldinst TC "2 Fault injection in latches of RT-Level model" \\f f}{\fldrslt }}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0 {\i0\scaps0\b Gate-Level Fault Injection:} Netlist fault injection can also be performed during RT-Level simulation, thereby supporting Gate-Level fault simulation. A simplified version of the method is depicted in Fig. {\field{\*\fldinst{\lang1024 REF BMsC2GT_inject \\* MERGEFORMAT }}{\fldrslt{2.3}}} (dotted, lighter colored lines indicate resources added for fault simulation purposes). In order to avoid cluttering the figure, we only show the resources for 3 out of the 10 fault injection sites; the rest of the sites are injected in the exact same way. In this simulation environment, every wire has an additional driver, which is controlled by the Fault Controller. Cells are treated as black boxes. The Fault Controller drives a high-impedance value {\f3 z} whenever a wire should not be fault-injected, so that the normal value of the wire is propagated. During fault-injection, a {\f3 supply0} or a {\f3 supply1} value is driven on the wire, resembling a stuck-at-0 or a stuck-at-1 fault, respectively. According to Verilog definition, if a wire has multiple drivers the strongest one prevails, with {\f3 z} being a neutral value. {\f3 Supply0} and {\f3 supply1} are the strongest signals, overwriting the regular {\f3 0} or {\f3 1} value of a signal and, thus, injecting a stuck-at fault.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 We point out that additional buffers are used in the diagram of Fig. {\field{\*\fldinst{\lang1024 REF BMsC2GT_inject \\* MERGEFORMAT }}{\fldrslt{2.3}}}, in order to enable fault-injection in the various segments of a wire with fanout. These buffers enable individual addressing and, thus, fault-injection on each of the branches of a fanout net. Finally, we also note that in order to successfully simulate a Gate-Level module in an RT-Level environment, the delays of all the standard cells are set to zero, matching the default zero propagation delay of an RT-Level model.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2GT_inject}3{\*\bkmkend BMsC2GT_inject}: Fault injection in wires of Gate-Level model (resources for 3 out of 10 fault injection sites shown)}{\field{\*\fldinst TC "3 Fault injection in wires of Gate-Level model (resources for 3 out of 10 fault injection sites shown)" \\f f}{\fldrslt }}\par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb360 \fi0 3.3  Simulation Flow\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 After presenting each component of the infrastructure, we now describe how these components are combined to provide the aforementioned capabilities. Fig. {\field{\*\fldinst{\lang1024 REF BMsC2flow \\* MERGEFORMAT }}{\fldrslt{2.4}}} presents a flow-chart of the procedure, where each of the three distinct components of Fig. {\field{\*\fldinst{\lang1024 REF BMsC2parts \\* MERGEFORMAT }}{\fldrslt{2.1}}} and their interactions are now depicted in more detail.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2flow}4{\*\bkmkend BMsC2flow}: Infrastructure utilization flow-chart}{\field{\*\fldinst TC "4 Infrastructure utilization flow-chart" \\f f}{\fldrslt }}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 Initially, for each entity that will be fault-injected, the corresponding fault code and fault list are added to the IVM model. Fault injection tools initialize the procedure, parse the given fault list and produce the necessary files to guide the functional simulator.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Following the initialization phase, the functional simulator starts execution and parses the fault injection parameters while updating the Fault Controller registers. Once the values are correctly set-up, the functional simulator executes a user-specified number of instructions. Given the fact that IVM lacks system-call support, initial system calls requested by applications must be executed by the functional simulator. When the simulator completes execution, the microprocessor state is transferred to the Verilog model.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 The Verilog implementation of the Alpha microprocessor simulates the rest of the program code. After a user-specified number of clock cycles, which is provided through a register in the Fault Controller, the latter activates the fault clock through which it instructs all modules to check whether they should alter any included entity (i.e. perform fault injection during the next clock cycle). At the end of the simulation, the state is saved and transferred back to the functional simulator.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 The functional simulator simply outputs the data collected by the Verilog model and stops execution. Subsequently, fault injection tools collect the data and perform the operations requested by the user. We should note that the whole process is very flexible and parameterized; the user can choose functionality (e.g. trace dumping, fault analysis), which faults to inject, when to inject each fault, and how long to inject it for. In this way, various types of studies are facilitated.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsC2ILEs}4{\*\bkmkend BMsC2ILEs}  Instruction Level Errors\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 We continue by introducing various types of instruction-level errors (ILEs), organized in several groups. While these ILE types constitute neither a complete nor a mutually exclusively set, they have been carefully selected to reflect incorrect behavior occurring due to faults in the control logic of a modern microprocessor. Thereby, these ILE types enable us to study the correlation between low-level faults in the hardware implementation of control logic and their instruction-level impact.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC2ILE_Types}4.1{\*\bkmkend BMsC2ILE_Types}  ILE Groups & Types\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In this study, we consider thirteen types of ILEs, organized in five distinct groups, as summarized in Table {\field{\*\fldinst{\lang1024 REF BMsC2ILE_Table \\* MERGEFORMAT }}{\fldrslt{2.2}}}. Such grouping reflects the five key aspects of instruction execution in a super-scalar out-of-order microprocessor, namely (i) the operation that is executed, (ii) the operands that are being used, (iii) the functional unit where execution takes place, (iv) the starting and finishing time of execution, and (v) the order of commitment. The various ILE groups and types are discussed in more detail below.\par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMsC2ILE_Table}2{\*\bkmkend BMsC2ILE_Table}: Instruction-Level Errors (ILEs)}{\field{\*\fldinst TC "2 Instruction-Level Errors (ILEs)" \\f t}{\fldrslt }}\par
{{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrdb\clbrdrt\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrt\brdrdb\clbrdrb\brdrs\cellx3912\clbrdrt\brdrdb\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc {  {\i0\scaps0\b Group 1:}}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 1:}}\cell}
{\pard\intbl\ql {Incorrect operation code used}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrdb\cellx3912\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { Operation Errors}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 2:}}\cell}
{\pard\intbl\ql {Invalid operation code used}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrs\cellx3912\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { }\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 3:}}\cell}
{\pard\intbl\ql {Incorrect register addressed}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrs\cellx3912\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { {\i0\scaps0\b Group 2:}}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 4:}}\cell}
{\pard\intbl\ql {Invalid register addressed}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrs\cellx3912\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { Operand Errors}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 5:}}\cell}
{\pard\intbl\ql {Premature use of register}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrdb\cellx3912\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc {}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 6:}}\cell}
{\pard\intbl\ql {Incorrect immediate operand}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrs\cellx3912\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc {  {\i0\scaps0\b Group 3:}}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 7:}}\cell}
{\pard\intbl\ql {Incorrect functional unit utilized}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrdb\cellx3912\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { Execution Errors}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 8:}}\cell}
{\pard\intbl\ql {Multiple functional units utilized}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrs\cellx3912\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { }\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 9:}}\cell}
{\pard\intbl\ql {Early commencement}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrs\cellx3912\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { {\i0\scaps0\b Group 4:}}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 10:}}\cell}
{\pard\intbl\ql {Late or no commencement}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrs\cellx3912\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc { Timing Errors}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 11:}}\cell}
{\pard\intbl\ql {Longer duration}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrdb\cellx3912\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc {}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Type 12:}}\cell}
{\pard\intbl\ql {Shorter duration}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\cellx3912\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc {  {\i0\scaps0\b Group 5:}}\cell}
{\pard\intbl\ql {}\cell}
{\pard\intbl\ql {}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx1750\clbrdrl\brdrs\clbrdrb\brdrdb\cellx3912\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6899
{\pard\intbl\qc {Order Errors}\cell}
{\pard\intbl\ql {}\cell}
{\pard\intbl\ql {}\cell}
\row}
} \par
}}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 4.1.1  Group 1: Operation Errors\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The first group covers errors in the operation code (op_code) of the instructions executed by the microprocessor, classified as one of the following ILE types:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 1:}} The op_code of an instruction is mutated to another op_code that is valid but incorrect. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 2:}} The op_code of an instruction is changed to an invalid op_code. \par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb180 \fi0 4.1.2  Group 2: Operand Errors\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The second group covers errors in the operands that are being used by an instruction. In certain instructions, such errors may also affect the instruction execution flow of a program and can, therefore, be considered as control errors. Our error model covers both registers and immediate operands through the following ILE types:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 3:}} A register address used by an instruction points to a valid but incorrect register file location. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 4:}} A register address used by an instruction points to an invalid register file location. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 5:}} An instruction uses the contents of a register prematurely, essentially violating a Read-After-Write (RAW) constraint. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 6:}} An instruction uses an incorrect immediate value as one of its operands. \par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb180 \fi0 4.1.3  Group 3: Execution Errors\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Super-scalar microprocessors employ several functional units of various types (e.g. integer ALUs, floating point ALUs, branch unit, memory operation unit, etc.), in order to execute multiple instructions simultaneously. Accordingly, the third group covers errors in the utilization of these functional units by the executed instruction through the following ILE types:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 7:}} An instruction is assigned to and executed by a functional unit of incorrect type. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 8:}} An instruction is assigned to more than one functional unit. \par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb180 \fi0 4.1.4  Group 4: Timing Errors\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The fourth group covers discrepancies in the timing of instruction execution. Such discrepancies manifest themselves via incorrect starting and/or finishing instruction execution times and are captured through the following ILE types:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 9:}} An instruction commences execution at an earlier clock-cycle than it is supposed to. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 10:}} An instruction commences execution at a later clock-cycle than it is supposed to, or does not commence execution at all. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 11:}} An instruction completes execution in a longer period of time than it is supposed to. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 12:}} An instruction completes execution in a shorter period of time that it is supposed to. \par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb180 \fi0 4.1.5  Group 5: Order Errors\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The fifth group covers errors in the order in which instructions are executed and committed. In a processor with out-of-order execution capabilities, the order in which instructions are scheduled and executed does not necessarily follow the program sequence. Therefore, a reorder buffer is typically used to keep track of the instructions that are in flight and ensure that they are committed in order. Errors causing discrepancies in this order are captured by the following ILE type:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b {Type 13:}} The correct order of instruction commitment is violated. \par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 4.2  Classification of Low-Level Faults as ILE Types\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In order to be able to appropriately categorize the impact of a low-level control logic fault into one of the ILE types introduced in the previous section, we use our fault simulation infrastructure to collect the necessary information. More specifically, for each clock cycle, we log various fields related to the execution of instructions in the processor. This is first done once for a golden run, wherein no fault is injected, and subsequently repeated on the fault injected processor for each fault. The two traces of information are compared and, at the first point of failure, the corresponding fields are used to classify the injected fault into an ILE type. The information that is collected from the various modules during each clock cycle is summarized in Table {\field{\*\fldinst{\lang1024 REF BMsC2Classify_Table \\* MERGEFORMAT }}{\fldrslt{2.3}}}. Evidently, the entire microprocessor needs to be simulated in order to accurately assess the impact of a low-level fault on instruction execution. Specifically, the traced information includes: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 1.\tab
the op_code of the instruction being executed; this is simply the type of the instruction. Based on this, ILEs of Types 1-2 can be identified. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 2.\tab
the physical addresses of the source and destination registers that are used by the instruction; this shows where the operands reside and where the result will be written. Based on this, ILEs of Types 3-4 can be identified. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 3.\tab
the ready bits of these registers; this indicates whether the source operands are ready to be read. Based on this, ILEs of Type 5 can be identified. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 4.\tab
the values of any immediate operands that the instruction may be utilizing. Based on this, ILEs of Type 6 can be identified. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 5.\tab
the identification number of the functional unit where the instruction is executed. Based on this, ILEs of Types 7-8 can be identified. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 6.\tab
the clock-cycle at which the instruction starts execution. Based on this, ILEs of Types 9-10 can be identified. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 7.\tab
the clock cycle at which the instruction is expected to finish execution. Based on this, ILEs of Types 11-12 can be identified. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 8.\tab
the ROBid of the instruction being executed; this is an identification number assigned by the Reorder Buffer which follows the instruction until it commits and serves as the mechanism for ensuring in-order instruction commitment in the out-of-order execution supported by IVM. Based on this, ILEs of Type 13 can be identified. \par
}{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb300 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMsC2Classify_Table}3{\*\bkmkend BMsC2Classify_Table}: ILE classification information traced from various microprocessor modules}{\field{\*\fldinst TC "3 ILE classification information traced from various microprocessor modules" \\f t}{\fldrslt }}\par
{{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrdb\clbrdrt\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3330\clbrdrl\brdrs\clbrdrt\brdrdb\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql {  {\i0\scaps0\b Module }}\cell}
{\pard\intbl\ql {{\i0\scaps0\b Information}}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3330\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Decoder}\cell}
{\pard\intbl\ql {Opcode, Operands, Immediate}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3330\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Rename}\cell}
{\pard\intbl\ql {Physical Registers}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3330\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Execution}\cell}
{\pard\intbl\ql {Functional Unit Utilization}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3330\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Scheduler}\cell}
{\pard\intbl\ql {Issue Time, Replays}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrs\clbrdrr\brdrs\cellx3330\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Scoreboard}\cell}
{\pard\intbl\ql {Availability of Operands}\cell}
\row}
{\trowd\clbrdrl\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx3330\clbrdrl\brdrs\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6899
{\pard\intbl\ql { Reorder Buffer (ROB)}\cell}
{\pard\intbl\ql {ROBid, Retirement Cycle/Order}\cell}
\row}
} \par
}}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 When fault-simulation of a benchmark completes its execution window, automated line-by-line comparison of its trace to the trace of the golden run is performed, as shown in Fig. {\field{\*\fldinst{\lang1024 REF BMsC2ILExample \\* MERGEFORMAT }}{\fldrslt{2.5}}}. In the event of a discrepancy, internally developed tools employ certain checks and algorithms to classify the fault to the appropriate Instruction-Level Error (ILE) type. Even though we compare line-by-line for differences between the golden trace and the faulty trace, when a discrepancy is found, information from multiple cycles is used to correctly classify the error. However, only the first discrepancy is reported and classified as an ILE, because the execution after that point is corrupted and will result in many different ILEs. If more than one ILE are identified in the clock cycle of first ILE appearance, all of them are reported.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2ILExample}5{\*\bkmkend BMsC2ILExample}: Example of classifying a low-level fault as a Type 3 ILE (incorrect register used)}{\field{\*\fldinst TC "5 Example of classifying a low-level fault as a Type 3 ILE (incorrect register used)" \\f f}{\fldrslt }}\par
}\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 {\*\bkmkstart BMsC2Experiments}5{\*\bkmkend BMsC2Experiments}  Experiments\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In this section, we demonstrate the error correlation capabilities and the corresponding insight that can be gained through the developed infrastructure. Specifically, we perform a series of simulations wherein low-level faults (either at the RT- or at the Gate-Level) are injected in the control logic of IVM while the latter executes SPEC2000 benchmarks and we analyze their instruction-level impact. We first discuss the details of the fault simulation setup; then, we present the obtained results and we reflect on the information that they provide and its potential significance in developing cost-effective CED methods.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC2Experimental_Setup}5.1{\*\bkmkend BMsC2Experimental_Setup}  Experimental Setup\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {\i0\scaps0\b Simulation Workload:} Seven different SPEC2000 benchmarks, namely {\f3 bzip2}, {\f3 mcf}, {\f3 parser}, {\f3 vortex}, {\f3 gzip}, {\f3 gap} and {\f3 cc} are used as the simulation workload. The use of multiple benchmarks ensures variability of the instructions executed through the processor and the control logic that they exercise. Each benchmark is executed by the functional simulator for an initial warm-up period of 50,000 clock cycles, at which point the machine state is transferred to the Verilog model and the execution continues for 2,000 cycles, during which a fault may be injected. On average, 1,297 instructions retire in this window of 2,000 clock cycles.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {\i0\scaps0\b Target Modules:} Since our focus is on microprocessor control logic, we target two key control modules: the Scheduler, which controls the allocation of instructions to execution units, and the ReOrder Buffer (ROB) which controls the order of instruction retirement. Both modules incorporate large buffers to support the number of instructions that can be in-flight, with a combined total of over 40,000 Verilog entities, as shown in Table {\field{\*\fldinst{\lang1024 REF BMsC2RT_level_stats \\* MERGEFORMAT }}{\fldrslt{2.4}}}. The Scheduler is relatively small; it contains 32 slots for instructions waiting to be executed and keeps the information needed to identify and correctly issue an instruction. The ROB is much larger because it contains a 64-slot instruction buffer, as well as complementary information about instruction retirement order.\par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMsC2RT_level_stats}4{\*\bkmkend BMsC2RT_level_stats}: Target module details}{\field{\*\fldinst TC "4 Target module details" \\f t}{\fldrslt }}\par
{{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrt\brdrdb\clbrdrb\brdrdb\cellx1130\clbrdrt\brdrdb\clbrdrb\brdrdb\cellx2339\clbrdrt\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrs\cellx3548\clbrdrl\brdrs\clbrdrt\brdrdb\clbrdrb\brdrdb\clbrdrr\brdrdb\cellx6898
{\pard\intbl\ql { }\cell}
{\pard\intbl\qr {{\i0\scaps0\b # of}}\cell}
{\pard\intbl\qr {{\i0\scaps0\b # of}}\cell}
{\pard\intbl\qr {{\i0\scaps0\b # of}}\cell}
\row}
{\trowd\cellx1130\cellx2339\clbrdrr\brdrs\cellx3548\clbrdrl\brdrs\clbrdrr\brdrdb\cellx6898\clbrdrl\brdrdb\cellx-268428558\cellx-268428558\cellx-536864014\cellx-536864014\cellx-536864014\cellx-536864014
{\pard\intbl\ql {{\i0\scaps0\b Module }}\cell}
{\pard\intbl\qr {{\i0\scaps0\b entities}}\cell}
{\pard\intbl\qr {{\i0\scaps0\b stdcells}}\cell}
{\pard\intbl\qr {{\i0\scaps0\b stuck-at faults}  Scheduler}\cell}
{\pard\intbl\q{9,411}\cell}
{\pard\intbl\q{170,099}\cell}
{\pard\intbl\q\u240? {1,159,012  ReOrder Buffer (ROB)}\cell}
{\pard\intbl\q{30,735}\cell}
{\pard\intbl\q{228,881}\cell}
{\pard\intbl\q{1,714,306  }\cell}
\row}
} \par
}}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 As shown in Table {\field{\*\fldinst{\lang1024 REF BMsC2RT_level_stats \\* MERGEFORMAT }}{\fldrslt{2.4}}}, the synthesized Scheduler consists of 170,099 standard cells, while the synthesized ROB consists of 228,881 standard cells. Even though the ROB has over 20K (228%) more storage elements than the Scheduler, it only uses 34% more standard cells. This is explained since, despite the fact that the ROB uses much larger buffers, the control logic involved is rather small and is only limited to the proper retirement of instructions. On the other hand, the Scheduler performs complicated tasks such as checking whether operands are ready, whether an instruction can be issued avoiding structural hazards etc., which involve much more control logic. The two modules employed in this study are quite diverse, one being a control-logic heavy and the other being buffer-heavy. Hence, we expect the results of our analysis to carry over to other modules that are mainly concerned with instruction execution flow.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {\i0\scaps0\b Injected Faults:} Both stuck-at and transient faults are considered in this study. For the transient fault model, we inject a bit-flip in every simulated clock-cycle, which translates to 2,000 fault simulation runs per fault location.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 While simulating the RT-Level versions of the two modules, all entities (presented in Table {\field{\*\fldinst{\lang1024 REF BMsC2RT_level_stats \\* MERGEFORMAT }}{\fldrslt{2.4}}}) are injected. At the gate-level, however, the number of faults is very large, since it includes faults both in the flip-flops and in the combinational logic, so we resort to sampling, with a sample size of {{\i c}=30%}. For the Scheduler, where the total number of faults is {{\field{\*\fldinst{ EQ {\i N}\\s\\do6({\fs20 {\i S}{\i c}{\i h}{\i e}{\i d}{\i u}{\i l}{\i e}{\i r}})=1\\,159\\,012}}{\fldrslt }}
}, this translates to a sample size of {{\field{\*\fldinst{ EQ {\i n}\\s\\do6({\fs20 {\i S}{\i c}{\i h}{\i e}{\i d}{\i u}{\i l}{\i e}{\i r}})=347\\,703}}{\fldrslt }}
} faults, while for the ROB, where {{\field{\*\fldinst{ EQ {\i N}\\s\\do6({\fs20 {\i R}{\i O}{\i B}})=1\\,714\\,306}}{\fldrslt }}
} faults, this translates to a sample size of {{\field{\*\fldinst{ EQ {\i n}\\s\\do6({\fs20 {\i R}{\i O}{\i B}})=514\\,290}}{\fldrslt }}
} faults. To assess the error incurred due to sampling, we use the following equation, defined in 
[{\field{\*\fldinst{\lang1024 REF BIB_Ag90 \\* MERGEFORMAT }}{\fldrslt{Ag90}}}
]: {\par
\pard\plain\s12\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\tqr\tx6900\sl240\slmult1 \fi0 \tab
{\field{\*\fldinst{ EQ {\i C}\\s\\do6({\fs20 0.99})={\i c}{\u177*}{\u949*}\\,{\u949*}= \\F({\i a}\\s\\up6({\fs20 2}){\i k},2{\i N}\\s\\do6({\fs20 {\i i}})) \\R(,1+ \\F(4{\i N}\\s\\do6({\fs20 {\i i}}){\i c}(1\u8722?{\i c}),{\i a}\\s\\up6({\fs20 2}){\i k}))}}{\fldrslt }}
\tab{\b0 ({\*\bkmkstart BMeq}1{\*\bkmkend BMeq})}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 where {{\u949*}} is the incurred error, {{\field{\*\fldinst{ EQ {\i C}\\s\\do6({\fs20 0.99})}}{\fldrslt }}
} is the range of fault coverage within which the true coverage lies with a confidence interval of {99%}, {{\field{\*\fldinst{ EQ {\i N}\\s\\do6({\fs20 {\i i}})}}{\fldrslt }}
} is the total number of faults, {{\i c}} is the fraction of faults to be simulated, {{\i a}=2.60} to achieve a confidence interval of {99%}, and {{\i k}=1} since the total population is large. Thus, our sample size of {{\i c}=30%} yields an error of {{\u949*}=0.01%}, which is more than adequate for the purpose of our analysis.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {\i0\scaps0\b Computational Power:} The experiments are performed on a Quad-core Xeon 3.33GHz with 16GB of memory.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC2Results}5.2{\*\bkmkend BMsC2Results}  Results and Analysis\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In this section we present the results of evaluating the impact of low-level faults on the instruction-level. The results are divided in three subsections:\par
{\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb100 \li600\fi-300 [i)]\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 1.\tab
First, we present results which reveal the correlation between RT-Level faults and the instruction-level errors that they cause.\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 2.\tab
Second, we present a comparative analysis of the impact of RT- vis-a-vis Gate-Level faults on instruction-level execution. These results corroborate that the above correlation remains valid independent of the level at which fault injection is performed.\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 3.\tab
Third, we present a comparative analysis of the impact of stuck-at faults vis-a-vis transient errors. Once again, the results corroborate that the correlation between low-level faults and instruction-level errors holds true, independent of the injected fault type.\par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb220 \fi0 {\*\bkmkstart BMsC2InstImpact}5.2.1{\*\bkmkend BMsC2InstImpact}  Instruction-Level impact of RT-Level stuck-at faults\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {{\ul Fault Simulation Statistics:}} As a first set of results, we present cumulative data regarding the fault simulations performed. Specifically, Table {\field{\*\fldinst{\lang1024 REF BMsC2SPEC_stats \\* MERGEFORMAT }}{\fldrslt{2.5}}} reports the percentage of the 80,804 injected faults (for both the Scheduler and the ROB) that resulted in an ILE, as well as the average number of ILE types that are simultaneously activated for each of the seven SPEC2000 benchmark programs that were executed. \par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMsC2SPEC_stats}5{\*\bkmkend BMsC2SPEC_stats}: Results on SPEC2000 Integer Benchmarks}{\field{\*\fldinst TC "5 Results on SPEC2000 Integer Benchmarks" \\f t}{\fldrslt }}\par
{{\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{threeparttable\} ... \\end\{threeparttable\}}]\par
}}}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 Based on this table, the following observations can be made:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The number of faults resulting in an ILE ranges between 16%-42%. Intuitively, faults injected during the execution of benchmark programs using a limited variety and algorithmic combination of instructions will excite fewer ILEs due to a larger portion of unused processor functionality. Certain register bits are rarely used in a typical execution flow (e.g. the most significant bits of address registers, or scheduler slots that are used only when a fairly large number of instructions are in flight). This high percentage of application-level masking highlights the advantage of using workload information to develop efficient CED techniques.\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Among the faults resulting in an ILE, an average of 99.3% also cause an architectural error. This high percentage elucidates the fact that the proposed ILE types constitute an effective way of capturing incorrect workload execution. The few faults that cause an ILE but do not affect the architectural state area attributed to either architectural masking (e.g. a fault that corrupts an instruction which never commits due to speculative execution) or performance faults (e.g. a fault that delays the availability of a functional unit and causes the workload to take longer to execute). We also note that, in our experiments, none of the faults may result in an incorrect architectural state but not cause an ILE.\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Since the ILE types are not mutually exclusive, more than one ILE types may be activated simultaneously, even when checking in a cycle-by-cycle fashion. However, as can be observed in the last column of Table {\field{\*\fldinst{\lang1024 REF BMsC2SPEC_stats \\* MERGEFORMAT }}{\fldrslt{2.5}}}, the average number of simultaneously activated ILE types is only 1.24; this implies that, most of the time, only one of the 13 ILE types is activated at the first point of failure. The implication of this information is that corruption will typically occur only at one aspect of instruction execution, with the rest remaining unaffected. Thus, early detection of such ILEs can guide simple local operations towards restoring the correct state of the microprocessor. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {{\ul Benchmark Consistency:}} Our second set of results examines the consistency of the information provided through our experiments. Specifically, since each benchmark utilizes different functional capabilities of the processor, the ILE type resulting from a stuck-at fault may vary, depending on the actual instructions being executed. In this sense, the robustness of the error correlation information may be questioned. Therefore, in Fig. {\field{\*\fldinst{\lang1024 REF BMsC2robustness \\* MERGEFORMAT }}{\fldrslt{2.6}}}, we present the percentage of stuck-at faults that results in ILEs of each of the five groups described in Section {\field{\*\fldinst{\lang1024 REF BMsC2ILE_Types \\* MERGEFORMAT }}{\fldrslt{2.4.1}}}, for each of the seven benchmark programs. \par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2robustness}6{\*\bkmkend BMsC2robustness}: Percentage of stuck-at faults causing each ILE group for each of the seven benchmarks}{\field{\*\fldinst TC "6 Percentage of stuck-at faults causing each ILE group for each of the seven benchmarks" \\f f}{\fldrslt }}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 Based on this bar-chart, the following observations can be made: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The distribution of stuck-at faults to the five groups of ILEs is consistent across the seven benchmarks. Furthermore, the variance of stuck-at faults within each group across the seven benchmarks is small. These observations corroborate that the obtained error correlation information is not biased by the actual instructions executed by each benchmark program and is, therefore, robust. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
A large percentage of stuck-at faults (60%-75%) result in timing errors in all benchmarks, implying that, independent of the workload utilized, most stuck-at faults in the control logic may not affect the instruction itself but, rather, when this instruction is executed. This is expected since faults injected in the Scheduler and the ROB modules directly impact instruction issuing and commitment. Such information is very useful in guiding allocation of error detection and recovery resources. In this case, for example, one would focus on methods that predict and monitor the correctness of instruction starting and stopping times, since, thereby, the majority of the faults would be detected. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {{\ul ILE Distribution:}} The third set of presented results relates to the occurrence frequency of each of the 13 ILE types described in Section {\field{\*\fldinst{\lang1024 REF BMsC2ILE_Types \\* MERGEFORMAT }}{\fldrslt{2.4.1}}}. The average number of stuck-at faults resulting in each ILE type over the seven benchmarks is presented in Fig. {\field{\*\fldinst{\lang1024 REF BMsC2results_types \\* MERGEFORMAT }}{\fldrslt{2.7}}}. The subset of these faults that eventually result in stalling of the pipeline is also provided. The following observations can be made based on the results:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The most frequently occurring ILEs concern instruction execution timing. Specifically, late instruction commencement (Type 10) and longer instruction duration (Type 11) are the dominant types. In other words, faults injected in the Scheduler and the ROB module will often result in failure to issue an instruction or failure to commit an instruction at the appropriate clock-cycle. Another interesting observation is the frequent appearance of operand mutations (Type 3). Indeed, the complex structures employed by the scheduler to keep track of the 1 to 3 registers used by each instruction, appear to be vulnerable to various stuck-at faults in the control logic. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
On the other hand, stuck-at faults in the Scheduler and the ROB seem to rarely cause mutation of operation codes (Type 2) or invalid operand address (Type 4), since the logic involved is relatively limited. Similarly, very few faults cause premature use of operands (Type 5), incorrect functional unit assignment (Types 7-8), or out-of-order instruction commitment (Type 13). In these cases, the involved logic can be large, but its complexity is such that it prevents single stuck-at faults in a register from activating these ILE types, hence their low occurrence probability. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Among the faults resulting in an ILE most (up to 80%) lead to a pipeline stall. In other words, while the initial error may only manifest in one aspect of instruction execution, if the error is not corrected promptly it will most likely have an avalanche effect that will eventually stall the processor. Moreover, our intuition is that the reported percentage is an under-estimate due to the limited fault simulation window of 2,000 cycles. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi360 The insight provided by the aforementioned observations regarding the most frequently occurring and, thus, the most critical ILE types can be leveraged to facilitate cost-effective use of error detection and correction resources. by implementing small, efficient CED techniques targeting specific ILE types.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {{\ul ILE Appearance Time:}} Another very interesting set of results pertains to the time that elapses between injection of a fault and its appearance as one of the defined ILE types, as well as the latency between appearance of an ILE and a potential subsequent stalling of the microprocessor. This information is provided in Fig. {\field{\*\fldinst{\lang1024 REF BMsC2results_times \\* MERGEFORMAT }}{\fldrslt{2.8}}}. While the activation time of an ILE may depend on the actual sequence of executed instructions, averaging the results over the seven SPEC2000 benchmarks provides an unbiased estimate. The obtained results motivate the following observations:\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2results_types}7{\*\bkmkend BMsC2results_types}: Average number of stuck-at faults causing each ILE Type and subsets causing stalled execution}{\field{\*\fldinst TC "7 Average number of stuck-at faults causing each ILE Type and subsets causing stalled execution" \\f f}{\fldrslt }}\par
}{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The average time until an injected fault results in an ILE is 406 clock cycles. However, the standard deviation across the 13 ILE types is rather high (198 clock cycles), with some ILE types occurring very quickly and others much later. For example, invalid operation code (Type 2), utilization of multiple functional units (Type 8) and incorrect commitment order (Type 13) are types of ILEs appearing very quickly after fault injection. Indeed, despite the fact that the set of faults causing these ILEs is relatively small (as presented in Fig. {\field{\*\fldinst{\lang1024 REF BMsC2results_types \\* MERGEFORMAT }}{\fldrslt{2.7}}}), such faults are directly associated with these specific types of ILEs. Thus, upon the appearance of such a fault, the corresponding ILE is immediately activated. On the other hand, ILEs related to timing issues (e.g. Types 9-11) appear much later. Such ILEs seem to be often the result of faults propagating to parts of the microprocessor that do not interfere directly with the main pipeline flow, yet eventually work their way into it and, hence, the longer latency. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
On average, a microprocessor stall occurs 280 clock cycles after occurrence of an ILE. However, one may observe that some ILEs concerning timing issues (i.e. Types 9-11) result in microprocessor stalling much faster than the rest of the ILEs; given the fact that these ILEs are caused when the Scheduler or the ROB fail to timely issue or commit an instruction, subsequent instructions fail to issue or commit successfully, inevitably causing the pipeline to stall very quickly. On the other hand, for ILEs such as Type 7, stalling appears much later, after the Scheduler and/or the ROB fill up with instructions waiting for the incorrectly executed instruction to retire. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi360 The insight provided by the aforementioned observations is two-fold. First, they reveal the relative temporal criticality of each ILE type. Thus, they can be used to fine-tune error tolerance methods that employ checkpoints to examine and restore the microprocessor state 
[{\field{\*\fldinst{\lang1024 REF BIB_WaPa05 \\* MERGEFORMAT }}{\fldrslt{WaPa05}}}
]. Second, they indicate the window of opportunity for correcting an error before it drastically corrupts the processor state and results in a stall. Thus, they can be leveraged to prioritize the allocation of error detection and correction resources.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Finally, Fig. {\field{\*\fldinst{\lang1024 REF BMsC2results_times \\* MERGEFORMAT }}{\fldrslt{2.8}}} shows that the activated ILEs appear no later than 1,200 cycles after fault injection; this ensures that the window of 2,000 clock cycles that we observe is sufficiently long for the performed analysis. While ILEs that would require a much larger simulation window to appear may exist, their number is relatively small and would not alter the profile of the results.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2results_times}8{\*\bkmkend BMsC2results_times}: Average time-stamp of ILE identification and subsequent pipeline stalling (in clock cycles)}{\field{\*\fldinst TC "8 Average time-stamp of ILE identification and subsequent pipeline stalling (in clock cycles)" \\f f}{\fldrslt }}\par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 5.2.2  Impact comparison of RT- vs. Gate-Level faults\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {{\ul Impact consistency:}} The first set of results compares the accuracy of assessing the impact of low-level faults on instruction execution at the RT- vs. the Gate-Level. Specifically, Fig. {\field{\*\fldinst{\lang1024 REF BMsC2Sch_ILEs \\* MERGEFORMAT }}{\fldrslt{2.9a}}} and {\field{\*\fldinst{\lang1024 REF BMsC2ROB_ILEs \\* MERGEFORMAT }}{\fldrslt{2.9b}}} present the classification of RT- and Gate-Level faults into the ILE types that they cause, for each of the seven benchmarks. The results are presented separately for the Scheduler and the ROB since the Scheduler is a control logic-heavy module whereas the ROB is a buffer-heavy module. \par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 [Scheduler]{} [ROB]{} \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2Sch_ILEs}9{\*\bkmkend BMsC2Sch_ILEs}: Comparison between ILE Types caused by RT- vs. Gate-Level faults}{\field{\*\fldinst TC "9 Comparison between ILE Types caused by RT- vs. Gate-Level faults" \\f f}{\fldrslt }}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 Based on the results, we can make the following observations:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The most important observation is a pronounced consistency in the types and frequency of ILEs caused by RT- vs. Gate-Level faults. Indeed, for each benchmark, the distribution of RT-Level faults to the 13 ILE types is strongly correlated with the distribution of Gate-Level faults to the same, as presented in Table {\field{\*\fldinst{\lang1024 REF BMsC2SPEC_stats_VTS \\* MERGEFORMAT }}{\fldrslt{2.6}}}. On average, the correlation coefficient{\cs62\super\chftn}
{\*\footnote\pard \s65\ql\fi-113\li397\lin397\f0\fs24{\cs62\super\chftn} If {{\i R}} is the vector containing the 13 values representing the percentage of the faults that result in each ILE Type for the RT-Level, and {{\i G}} is the same vector for the Gate-Level ({{\f5\u772\'5f}{\i R}} and {\u7712G} being the respective average values) then the correlation coefficient {{\i c}} is calculated as:\par
{\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \li600\fi0 {{\field{\*\fldinst{ EQ {\i c}= \\F( \\i \\su({\i n}=1,13, ){({\i R}\\s\\do6({\fs20 {\i n}})\u8722?{\f5\u772\'5f}{\i R})({\i G}\\s\\do6({\fs20 {\i n}})\u8722?\u7712G)}, \\R(,( \\i \\su({\i n}=1,13, ){({\i R}\\s\\do6({\fs20 {\i n}})\u8722?{\f5\u772\'5f}{\i R})\\s\\up6({\fs20 2})})( \\i \\su({\i n}=1,13, ){({\i G}\\s\\do6({\fs20 {\i n}})\u8722?\u7712G)\\s\\up6({\fs20 2})})))}}{\fldrslt }}
} \par
}}
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 is 93% for both the Scheduler and the ROB. This critical observation corroborates that RT-Level fault analysis provides sufficiently accurate results with respect to its Gate-Level counterpart.\par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \li600\fi0  {\par
{\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \li600\fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{threeparttable\} ... \\end\{threeparttable\}}]\par
}}}\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The next observation is that the distributions are consistent across the various benchmarks, confirming the results presented in the previous section. Hence, it is evident that the type of ILE caused by a low-level fault is, typically, independent of the instruction subset that is utilized.\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
A final observation is that some ILE types appear never to be caused by Gate-Level faults. These ILE types have already a very small frequency of occurrence due to RT-Level faults, which is further diminished during Gate-Level fault simulation because of sampling. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {{\ul Fault simulation speed:}} The next set of results investigates how the simulation speed is affected by the use of Gate-Level modules. Table {\field{\*\fldinst{\lang1024 REF BMsC2Simulationspeed \\* MERGEFORMAT }}{\fldrslt{2.7}}} compares the average simulation time per fault for the various configurations. The first row provides the baseline, where all modules are simulated at the RT-Level, while the following rows indicate the overhead when one or both of the target modules are simulated at the Gate-Level. As may be observed, this makes the simulation over an order of magnitude slower. Taking into account that, even with 30% fault sampling, using the Gate-Level Scheduler and ROB requires, on average, 5.8x (5.0x for Scheduler, 6.6x for ROB) more fault simulations than their RT-Level counterparts, a similar fault analysis at the Gate-Level is 260x more expensive, rendering it almost infeasible for extensive studies. Therefore, performing the simulations at the RT-Level is strongly desired, especially since the accuracy of the obtained results is up to par, as confirmed by the above results.\par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0  \par
{\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{threeparttable\} ... \\end\{threeparttable\}}]\par
}}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 5.2.3  Impact comparison of stuck-at vs. transient faults\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {{\ul Transient fault classification:}} We now compare the impact of two different fault models, namely stuck-at faults and bit-flip transients, on instruction execution. We note that, while classifying the impact of a stuck-at fault to an ILE is rather straightforward, doing so for a transient fault is more complicated. Indeed, transients in the same location may result in a different ILE type depending on the time of fault injection during the simulation. Therefore, for each fault we perform 2,000 simulations, each time injecting it at a different clock cycle and we collect the probability with which this fault will lead to an ILE of each type. For example, assume that a stuck-at fault in a register causes an ILE of Type 3, while a bit-flip in the same register results in an ILE of Type 3 if injected in clock cycles 10, 500 or 1200 and as ILE of Type 11 if injected in clock cycles 250 or 1500. Then, this transient fault contributes 0.6 to the number of transient faults that result in an ILE of Type 3 and 0.4 to the number of transient faults that result in an ILE of Type 11. In contrast, the corresponding stuck-at fault contributes 1 to the number of faults resulting in an ILE of Type 3.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {{\ul Impact consistency:}} Fig. {\field{\*\fldinst{\lang1024 REF BMsC2Stuck_Trans \\* MERGEFORMAT }}{\fldrslt{2.10}}} shows the combined results for the Scheduler and the ROB for the 7 different benchmarks. The results reveal a very high consistency between the distribution of stuck-at and transient faults to the corresponding ILEs (i.e. an average correlation coefficient of 98%). This consistency can be further explained by examining the impact of individual transient faults. While a transient may result in various ILE types depending on its time of injection, it turns out that, most of the time (over 80% on average), it causes the same ILE. Hence, even if one is interested in developing CED methods for transient bit-flips, assessing their instruction-level impact through stuck-at fault simulations would provide sufficiently accurate results. Moreover, as explained in the previous paragraph, assessing instruction-level impact through simulation of stuck-at faults is far less time-consuming than through transient faults, since only one simulation is necessary per fault location.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC2Stuck_Trans}10{\*\bkmkend BMsC2Stuck_Trans}: Comparison between ILE Types caused by stuck-at vs. transient faults in the Scheduler and the ROB}{\field{\*\fldinst TC "10 Comparison between ILE Types caused by stuck-at vs. transient faults in the Scheduler and the ROB" \\f f}{\fldrslt }}\par
}\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 6  Conclusions\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In order to develop cost-effective CED methods which leverage the ability of modern microprocessors to suppress a high percentage of errors at the application level, a thorough understanding of the impact of low-level faults on program execution is necessary. To this end, the infrastructure reported herein, which we developed around an Alpha-like high-performance microprocessor, enables injection, simulation and classification of low-level faults into instruction-level error types. Extensive experimentation with this infrastructure provided great insight regarding the relative importance of low-level faults, as gauged by the activation frequency and latency of the instruction-level error types that they cause. Furthermore, it revealed a profound instruction-level impact consistency between RT- and Gate-Level faults, as well as between stuck-at and transient faults. Besides CED, the capabilities of the developed infrastructure may be utilized to provide similar insight and guidance for various other design robustness endeavors.\par
\page
\pard\plain\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \fi0 Chapter {\*\bkmkstart BMsC3}3{\*\bkmkend BMsC3}\par
\pard\plain\s2\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb240 \fi0 Error detection and correction for microprocessor control logic\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 1  Introduction\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The pluralism of Concurrent Error Detection (CED) methods that have been proposed in the past implies that no one solution fits the needs of every circuit. Furthermore, it stresses the fact that applying generic solutions across the board for an entire design typically incurs prohibitive cost, often times unnecessarily and without providing commensurate coverage. Indeed, in order to maintain cost-effectiveness, it is important to understand the specific vulnerabilities and requirements of a circuit and accordingly tailor the CED solution.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Modern microprocessors, as discussed in Section {\field{\*\fldinst{\lang1024 REF BMsC2Intro \\* MERGEFORMAT }}{\fldrslt{2.1}}}, exhibit a high degree of application-level error masking. Indeed, the multitude of functional units and stages in deeply-pipelined superscalar microprocessors, along with advanced architectural features such as dynamic scheduling and speculative execution, imply that rather complex conditions need to be satisfied for an error to affect the architectural state of the microprocessor. Furthermore, it is well-known that the probability with which faults are suppressed is asymmetric 
[{\field{\*\fldinst{\lang1024 REF BIB_Mo03b \\* MERGEFORMAT }}{\fldrslt{Mo03b}}}
], implying that not all faults are equally critical. Hence, high-level methods that aim to globally monitor the most susceptible aspects of instruction execution, rather than to locally check the result of every fine-grain hardware entity, appear to be the most promising direction towards developing cost-effective CED solutions.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 To this end, we leverage the information provided by the workload-cognizant, cross-layer impact analysis methodology presented in Chapter {\field{\*\fldinst{\lang1024 REF BMsC2 \\* MERGEFORMAT }}{\fldrslt{2}}} to develop cost effective CED solutions for the control logic of the main processing units of a modern chip: The Central Processing Unit (CPU), presented in Section {\field{\*\fldinst{\lang1024 REF BMsC2CEDCPU \\* MERGEFORMAT }}{\fldrslt{3.2}}}, and the Floating-Point Unit (FPU), presented in Section {\field{\*\fldinst{\lang1024 REF BMsC2CEDFPU \\* MERGEFORMAT }}{\fldrslt{3.3}}}.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsC2CEDCPU}2{\*\bkmkend BMsC2CEDCPU}  CED for CPU controllers\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 2.1  Introduction\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In this section, we develop a workload-cognizant CED scheme for the Scheduler of a modern microprocessor, based on detailed information regarding the impact of faults on the instruction execution of typical programs. Specifically, we use the infrastructure and the results presented in Chapter {\field{\*\fldinst{\lang1024 REF BMsC2 \\* MERGEFORMAT }}{\fldrslt{2}}} in order to understand the relative importance of the various ILEs that are caused by faults in the Scheduler of the microprocessor. Guided by the results of this analysis, we incorporate additional hardware that monitors the most vulnerable aspects of instruction execution. Specifically, we predict and validate the time and the functional unit where an instruction is executed, along with four hardware-imposed {\i invariances} (i.e. properties which hold true during error-free operation but which are violated in the presence of errors), which validate the operation code and the operands of an instruction, as well as the sequence in which instructions are executed and retired. Extensive fault simulation-based evaluation validates that workload information can, indeed, drive the development of cost-effective CED methods.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 The remainder of this section is organized as follows. In section {\field{\*\fldinst{\lang1024 REF BMsC3sPrevious \\* MERGEFORMAT }}{\fldrslt{3.2.2}}} we discuss related work in CED. Then, in section {\field{\*\fldinst{\lang1024 REF BMsC3sScheduler \\* MERGEFORMAT }}{\fldrslt{3.2.3}}}, we provide more details about the Scheduler of this microprocessor, which is the target of our CED scheme. The details of the developed CED scheme are given in section {\field{\*\fldinst{\lang1024 REF BMsC3sCED \\* MERGEFORMAT }}{\fldrslt{3.2.4}}}. Finally, extensive fault simulation results demonstrating the effectiveness of the proposed CED scheme are presented and discussed in section {\field{\*\fldinst{\lang1024 REF BMsC3sResults \\* MERGEFORMAT }}{\fldrslt{3.2.5}}} and conclusions are drawn in section {\field{\*\fldinst{\lang1024 REF BMsC3sConclusion \\* MERGEFORMAT }}{\fldrslt{3.2.6}}}.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC3sPrevious}2.2{\*\bkmkend BMsC3sPrevious}  Related Work\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Various CED solutions 
[{\field{\*\fldinst{\lang1024 REF BIB_GoGr93 \\* MERGEFORMAT }}{\fldrslt{GoGr93}}}, {\field{\*\fldinst{\lang1024 REF BIB_MiMc00 \\* MERGEFORMAT }}{\fldrslt{MiMc00}}}
] have been proposed in the past to detect faults or errors occurring during normal operation of a circuit after it is deployed in the field. Among those, the simplest approach is duplication, wherein a replica of the circuit is added to the design, possibly diversely implemented (e.g. through the use of dual-rail logic 
[{\field{\*\fldinst{\lang1024 REF BIB_923436 \\* MERGEFORMAT }}{\fldrslt{923436}}}
]) to avoid common mode failures 
[{\field{\*\fldinst{\lang1024 REF BIB_AvKe84 \\* MERGEFORMAT }}{\fldrslt{AvKe84}}}
]. The original and the replica serve as predictors of the functionality of each other and a simple comparator indicates any discrepancy in their outputs, thus detecting potential malfunctions. While simple, this technique is prohibitively expensive. To reduce the overhead imposed by duplication-based techniques, partial duplication has been suggested to detect the faults in the most critical parts of the design 
[{\field{\*\fldinst{\lang1024 REF BIB_Mo03b \\* MERGEFORMAT }}{\fldrslt{Mo03b}}}
].\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Another very popular CED approach has been the use of various codes, especially within the context of finite state machine (FSM) controllers. Several redesign and resynthesis methods are described in 
[{\field{\*\fldinst{\lang1024 REF BIB_AkSo75 \\* MERGEFORMAT }}{\fldrslt{AkSo75}}}, {\field{\*\fldinst{\lang1024 REF BIB_DhVr88 \\* MERGEFORMAT }}{\fldrslt{DhVr88}}}
], wherein parity or various unordered codes are employed to encode the states of the circuit. Utilization of multiple parity bits is also examined in 
[{\field{\*\fldinst{\lang1024 REF BIB_ZSM98 \\* MERGEFORMAT }}{\fldrslt{ZSM98}}}
] within the context of FSMs. These methods guarantee latency-free error detection; on the down side, they are intrusive and expensive. Non-intrusive CED methods have also been proposed. Implementations based on Hamming, Bose-Lin and Berger codes are presented in 
[{\field{\*\fldinst{\lang1024 REF BIB_1030186 \\* MERGEFORMAT }}{\fldrslt{1030186}}}
], 
[{\field{\*\fldinst{\lang1024 REF BIB_670885 \\* MERGEFORMAT }}{\fldrslt{670885}}}
] and 
[{\field{\*\fldinst{\lang1024 REF BIB_229762 \\* MERGEFORMAT }}{\fldrslt{229762}}}
], respectively, while parity-based CED methods are described in 
[{\field{\*\fldinst{\lang1024 REF BIB_GoGr93 \\* MERGEFORMAT }}{\fldrslt{GoGr93}}}, {\field{\*\fldinst{\lang1024 REF BIB_ADM06 \\* MERGEFORMAT }}{\fldrslt{ADM06}}}, {\field{\*\fldinst{\lang1024 REF BIB_1676055 \\* MERGEFORMAT }}{\fldrslt{1676055}}}
]. While the aforementioned methods guarantee latency-free detection of all errors, their cost is often prohibitive. Trading-off the incurred cost by allowing a non-zero, yet bounded error detection latency has also been investigated 
[{\field{\*\fldinst{\lang1024 REF BIB_AMD04 \\* MERGEFORMAT }}{\fldrslt{AMD04}}}
].\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 At a coarser level, an attempt to identify inherent invariance either at the gate-level 
[{\field{\*\fldinst{\lang1024 REF BIB_VJAPG08 \\* MERGEFORMAT }}{\fldrslt{VJAPG08}}}
] or at the RTL 
[{\field{\*\fldinst{\lang1024 REF BIB_1308673 \\* MERGEFORMAT }}{\fldrslt{1308673}}}
] of a design has been made. Such invariance can be monitored during the normal operation of a circuit to identify errors that cause it to be violated. In 
[{\field{\*\fldinst{\lang1024 REF BIB_VJAPG08 \\* MERGEFORMAT }}{\fldrslt{VJAPG08}}}
] such invariance is mined from the gate-level of a controller implementation in the form of assertions, which are evaluated through simulation in order to select a cost-effective appropriate subset. The same principle governs the approach in 
[{\field{\*\fldinst{\lang1024 REF BIB_1308673 \\* MERGEFORMAT }}{\fldrslt{1308673}}}
]; therein, however, invariance is identified through a path-construction algorithm, which exploits inherent transparency channels that exist in the RTL description of a modular design. More recently, the method proposed in 
[{\field{\*\fldinst{\lang1024 REF BIB_MROJG08 \\* MERGEFORMAT }}{\fldrslt{MROJG08}}}
] also leverages inherent invariant codes to perform CED in the decoder of the same microprocessor that we employ in this study.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 At an even higher architectural level, several concurrent error detection and/or correction methods have been proposed. The concept of watchdog processors, which compute control-flow signatures and compare them to expected correct values, known at compilation time, is proposed in 
[{\field{\*\fldinst{\lang1024 REF BIB_2145 \\* MERGEFORMAT }}{\fldrslt{2145}}}, {\field{\*\fldinst{\lang1024 REF BIB_JN08 \\* MERGEFORMAT }}{\fldrslt{JN08}}}
]. Concepts akin to instruction-level duplication and comparison to identify erroneous results are examined in 
[{\field{\*\fldinst{\lang1024 REF BIB_MeSu00 \\* MERGEFORMAT }}{\fldrslt{MeSu00}}}, {\field{\*\fldinst{\lang1024 REF BIB_941424 \\* MERGEFORMAT }}{\fldrslt{941424}}}
]. In 
[{\field{\*\fldinst{\lang1024 REF BIB_WQRP04 \\* MERGEFORMAT }}{\fldrslt{WQRP04}}}
], the authors examine the vulnerability of different parts of a microprocessor to soft errors and recommend various strategies (including register file protection with codes, parity coding to protect instruction words, and a timeout counter to flush the pipeline when no activity occurs for prolonged periods) to detect/correct such errors. Similar analysis is performed in 
[{\field{\*\fldinst{\lang1024 REF BIB_MWERA03 \\* MERGEFORMAT }}{\fldrslt{MWERA03}}}
], based on the concept of Architectural Vulnerability Factor (AVF), which prioritizes microprocessor modules based on their susceptibility. Such metrics can prove very useful in guiding allocation of CED resources.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC3sScheduler}2.3{\*\bkmkend BMsC3sScheduler}  Scheduler Module\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The Scheduler is one of the key control modules in any modern microprocessor with advanced architectural features. In IVM, the Scheduler is a dynamic module containing an array of up to 32 instructions waiting to be issued, from which up to 6 instructions are issued in each clock cycle. Each instruction coming to the Scheduler resides in this buffer until an acknowledgment is received from the execution unit that it can start execution. At this time, the corresponding location in the Scheduler waiting-list is cleared for use by another newly arriving instruction. The Scheduler issues instructions out-of-order after considering the availability of instructions of various types in the buffer, as well as the existence of structural or data hazards.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 During instruction execution, avoidance of structural and data hazards is ensured by the Scheduler, while avoidance of control hazards is ensured by the Reorder Buffer (ROB). Indeed, the Scheduler considers structural hazards before issuing an instruction. The IVM microprocessor has 6 functional units: 2 simple, 1 complex, 1 branch and 2 memory units. Thus, up to 6 instructions with the above limitations on the type and distribution of instructions can be issued in each clock cycle. Write-After-Read (WAR) and Write-After-Write (WAW) data hazards are taken care of by the Rename module of IVM before the instruction comes to the Scheduler. Read-After-Write (RAW) data hazards, however, may still exist due to dependencies between instruction operands. To deal with such RAW hazards, the Scheduler uses the Scoreboard method 
[{\field{\*\fldinst{\lang1024 REF BIB_hennessy2011computer \\* MERGEFORMAT }}{\fldrslt{hennessy2011computer}}}
]. Based on the type of functional unit that will be executing an instruction, the Scoreboard determines the clock cycle in which the destination register for this instruction will be written and available for other instructions to read. Consequently, the Scheduler prevents issuing of instructions that need to use this register prior to the time that it becomes available. Along with each instruction coming to the Scheduler from the Rename module, a unique identification number called ROBid is also provided by the ROB module. This ROBid follows the instruction until it commits and serves as a mechanism for ensuring in-order instruction commitment in the out-of-order execution of the microprocessor and avoiding control hazards.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Figure {\field{\*\fldinst{\lang1024 REF BMsC3Scheduler \\* MERGEFORMAT }}{\fldrslt{3.1}}} shows the high level diagram of the IVM Scheduler module. As shown in this figure, instructions arriving to the Scheduler continue to reside in the buffer even if they have been issued to the Execution unit, until the execution unit confirms that they can start execution. At this time the \ldblquote valid" and \ldblquote issued" signals of the related instruction in the Scheduler are disabled and the corresponding buffer locations are considered available for use by subsequent instructions.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC3Scheduler}1{\*\bkmkend BMsC3Scheduler}: Block diagram of IVM Scheduler}{\field{\*\fldinst TC "1 Block diagram of IVM Scheduler" \\f f}{\fldrslt }}\par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb360 \fi0 {\*\bkmkstart BMsC3sCED}2.4{\*\bkmkend BMsC3sCED}  Scheduler CED Scheme\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Based on the observations presented in Section {\field{\*\fldinst{\lang1024 REF BMsC2InstImpact \\* MERGEFORMAT }}{\fldrslt{2.5.2}}}, where timing errors where identified as dominant, the timestamp-based CED scheme proposed in this section seeks to verify the following aspects of instruction execution, which are listed in decreasing order of significance:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Correctness of the time at which an instruction starts executing. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Correctness of the operands used by the instruction. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Correctness of the operation code executed by the instruction. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Correctness of the sequence in which instructions are actually executed, taking into account branches. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Correctness of the sequence in which instructions arrive to the scheduler. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Correctness of the functional unit to which an instruction is assigned for execution. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi360 To achieve the above objectives, the proposed CED scheme involves two components. The first component employs additional hardware which predetermines the time at which an instruction should start execution and the functional unit where it should be executed, as explained in Section {\field{\*\fldinst{\lang1024 REF BMsC3sTimePlace \\* MERGEFORMAT }}{\fldrslt{3.2.4}}}. Using this information, the second component employs additional hardware to impose and monitor four invariances that should hold true in each clock cycle {{\i i}} and for each functional unit {{\i j}}:\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Invariance #1:} Equality between the ROBid of the instruction that is predicted to be executed at time {{\i i}} by functional unit {{\i j}} and the ROBid of the instruction that is actually executed. Monitoring this invariance ensures correct order in the commitment of instructions. Thereby, this invariance aims mainly at detecting ILEs of Group 5 (Order Errors).\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Invariance #2:} Parity consistency between the operation code of the instruction that is predicted to be executed at time {{\i i}} by functional unit {{\i j}} and the operation code of the instruction that is actually executed. This invariance aims mainly at detecting ILEs of Group 1 (Operation Errors).\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Invariance #3:} Parity consistency between the operands (up to three) of the instruction that is predicted to be executed at time {{\i i}} by functional unit {{\i j}} and the operands used by the instruction that is actually executed. This invariance aims mainly at detecting ILEs of Group 2 (Operand Errors).\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
{\i0\scaps0\b Invariance #4:} Parity consistency between the target address of the instruction that is predicted to be executed at time {{\i i}} by functional unit {{\i j}} and the target address of the instruction that is actually executed. Checking this invariance ensures the correctness of execution flow following branch instructions. Thereby, it aims mainly at detecting ILEs of Group 4 (Timing Errors). \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 We note that no invariance that explicitly checks for ILEs of Group 3 (Execution Errors) is included in our CED scheme. However, such errors are implicitly detected through the prediction of the functional unit where the invariances are checked. Furthermore, as we observed through the fault impact analysis of the previous section, such faults are the least important among the ILE types.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Figure {\field{\*\fldinst{\lang1024 REF BMsC3fexe_time_pred \\* MERGEFORMAT }}{\fldrslt{3.2}}} shows the hardware that needs to be added to the IVM Scheduler in order to support the proposed CED scheme. As we described in section {\field{\*\fldinst{\lang1024 REF BMsC3sScheduler \\* MERGEFORMAT }}{\fldrslt{3.2.3}}}, the Scheduler contains an array where up to 32 instructions coming from the Rename module reside until all structural and data hazards are cleared so that they can be sent for execution. Each entry in this array contains 224 bits comprising the various fields of the instruction, as shown in the figure. Our scheme relies on the construction of a CED Table, which partially replicates this array by keeping only the fields needed for predicting the time and place where an instruction should be executed and supporting the subsequent invariance checking. Specifically, the retained information includes the ROBid, the instruction type, as well as the parity of the operation code, the operands, and the target address if the instruction is a branch. The instruction type, along with information from the existing Scoreboard module and the original instruction array are then used to predict and add to the CED Table the functional unit where an instruction will be dispatched and its execution starting time, expressed as an offset relative to the current clock cycle. All in all, each entry in this Table contains 24 bits.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC3fexe_time_pred}2{\*\bkmkend BMsC3fexe_time_pred}: Hardware additions to the IVM Scheduler to support the proposed CED scheme}{\field{\*\fldinst TC "2 Hardware additions to the IVM Scheduler to support the proposed CED scheme" \\f f}{\fldrslt }}\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360 Given the information in the CED Table, monitoring the four invariances becomes straightforward, as shown in Figure {\field{\*\fldinst{\lang1024 REF BMsC3finvariance \\* MERGEFORMAT }}{\fldrslt{3.3}}}. In each clock cycle, we look at the instruction executed by each functional unit and we extract its ROBid, along with the parity of its operation code, its operands, and its target address. We then compare these fields to the corresponding fields of the instruction that the CED Table predicts as the one that should be executed by this functional unit at this particular time. Any discrepancy signifies an error, in which case the CED output is asserted.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi360  \par
\pard\plain\s9\qc\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMsC3finvariance}3{\*\bkmkend BMsC3finvariance}: Invariance checking by proposed CED scheme}{\field{\*\fldinst TC "3 Invariance checking by proposed CED scheme" \\f f}{\fldrslt }}\par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 {\*\bkmkstart BMsC3sTimePlace}2.4.1{\*\bkmkend BMsC3sTimePlace}  Predicting Instruction Execution Time & Place\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The proposed CED method relies on correctly predicting the time that each instruction will start execution as well as the functional unit to which it will be issued. To achieve this, several parameters need to be considered. First, the availability of resources in the execution unit, which also bounds the maximum number and types of instructions that can be issued in each cycle. IVM includes 6 functional units, namely 2 simple units, 1 complex unit, 1 branch unit and 2 memory units. Second, the types and order of arrival of instructions that are waiting to be issued for execution. And, third, the data hazards that an instruction may cause.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 Let us consider an instruction that arrives at the Scheduler at clock cycle {{\i c}}. The earliest that this instruction can be issued is at clock cycle {{\i c}+1} and the earliest it can start execution is at clock cycle {{\i c}+3}, with the added clock cycles accounting for the pipeline depth between the Scheduler and the Execution Unit. In other words, for the incoming instructions whose issue does not generate any hazard, the execution starting time is determined precisely as soon as the instruction enters the Scheduler. Before an instruction is issued, however, resource availability needs to be considered. Specifically, preceding instructions that are already residing in the Scheduler waiting table are examined first; if their operands are available and their issuing causes no structural hazards they are given priority over the current instruction, which remains in the Scheduler.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 For the instructions which cannot be sent out of the Scheduler in the clock cycle following the clock cycle they enter the Scheduler module, a rough estimate of their execution starting time is made and updated each clock cycle. This estimate depends on the number of instructions of the same type that reside in the Scheduler waiting table, the number of available functional units to execute instructions of this type, as well as the dependencies between the operands of all unissued instructions. In each clock cycle, up to 6 instructions are issued and the Scheduler waiting table fields are updated. Accordingly, the aforementioned estimates are also updated, until we can determine when all structural and data hazards will be resolved so that we can predict the clock cycle that an instruction will be able to start execution and the functional unit where it will be dispatched. To reduce hardware overhead, the execution starting time of each instruction is expressed as an offset from the current clock cycle.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 We also note that although the Scheduler checks the availability of operands before issuing an instruction, a second check takes place in the Execution module. This is required since an operand that was supposed to be available at the required clock cycle (based on the information provided by the Scoreboard), may be not available due to a cache miss. In this case, the Execution unit reports that an instruction needs to be reissued and our method recalculates the new execution starting time.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {\i0\scaps0\b Example:} Consider Figure {\field{\*\fldinst{\lang1024 REF BMsC3fexe_time_pred \\* MERGEFORMAT }}{\fldrslt{3.2}}} which shows a snapshot of the Scheduler waiting table (upper) and the CED table (lower) and let us assume that four instructions arrive at the Scheduler at clock cycle {{\i c}} and are placed in rows 3 through 6 of each table. Let us also assume that no other unissued instructions of these types are waiting in the Scheduler. Based on the instruction types and required operands, our CED scheme determines that the first 2 instructions (rows 3 and 4) can be issued in the following clock cycle. Taking into account the pipeline depth of 3 between the Scheduler and the Execution unit of IVM, these two instructions can start execution at clock cycle {{\i c}+3}. Accordingly, the offset \ldblquote 3\rdblquote  is placed in the 6th column of rows 3 and 4 in the CED table. However, the branch instruction (row 5) cannot start execution simultaneously with the aforementioned two instructions due to its operand dependency (r54) on the simple instruction (row 4). Hence, our CED scheme consults the Scoreboard regarding the availability time of register r54. Since a simple instruction takes one cycle to execute and the producing instruction starts execution in {{\i c}+3}, the Scoreboard responds that r54 will be available in clock cycle {{\i c}+4}. Accordingly, clock cycle {{\i c}+4} is predicted as the execution starting time of the branch instruction and the offset \ldblquote 4\rdblquote  is placed in the 6th column of row 5 in the CED table. The next instruction (row 6) is a complex instruction (i.e. multiply) and cannot be immediately issued due to a structural hazard (the first instruction is occupying the complex functional unit). In addition, the first operand of this instruction is r16 which is the destination register of the first instruction (row 3). The multiply unit of the IVM is implemented as a 5-stage pipeline, our CED scheme predicts that the earliest clock cycle at which the instruction in row 6 can start execution is {{\i c}+8}. Accordingly, the offset \ldblquote 8\rdblquote  is placed in the 6th column of the row 6 of the CED table.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsC3sResults}2.5{\*\bkmkend BMsC3sResults}  Results and Analysis\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In this section, we provide the results of the proposed CED effectiveness and we discuss our key observations. The results are divided in four sets; the first set provides statistics on fault activation, the second set evaluates the effectiveness of the proposed CED scheme, the third set demonstrates the utility of the impact analysis information based on which the CED scheme was designed, and the fourth set examines various other properties of the CED scheme.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 The experimental setup used for this study, in terms of benchmarks utilized and fault modeling, was presented in Section {\field{\*\fldinst{\lang1024 REF BMsC2Experimental_Setup \\* MERGEFORMAT }}{\fldrslt{2.5.1}}}. For the presented CED scheme, fault injection was performed only on the Scheduler.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 2.5.1  Fault Activation Profile\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {{\ul Fault simulation outcome:}} The first set of results, presented in Table {\field{\*\fldinst{\lang1024 REF BMsC3tfaultclass \\* MERGEFORMAT }}{\fldrslt{3.1}}}, summarizes the fault simulation outcome for each benchmark. The second column reports the number of faults that were activated, i.e. they adversely affected the functionality of the microprocessor. On average, 38.1% of the faults resulted in a visible discrepancy. In the third through fifth columns we further split these faults into three categories, based on their impact on instruction execution. As can be observed, an average of 20.4% of the activated faults resulted in incorrect architectural state after the executed 2,000 clock cycles, 11.3% resulted in a stalling of the pipeline, and 6.4% resulted in an exception system call prior to completion of benchmark execution. The final column reports the number of faults that were masked, i.e. they did not affect benchmark execution at all. The high percentage of such errors, averaging at 61.9% over the six benchmarks, corroborates our conjecture that application-level error masking plays an important role in modern microprocessors, which motivated the development of the proposed workload-cognizant CED scheme. After all, only a small portion of the functionality of the the Scheduler module is exercised by typical workload, hence a large number of faults are either not excited at all or are excited but are logically suppressed.\par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMsC3tfaultclass}1{\*\bkmkend BMsC3tfaultclass}: Fault simulation outcome after 2,000 clock cycles}{\field{\*\fldinst TC "1 Fault simulation outcome after 2,000 clock cycles" \\f t}{\fldrslt }}\par
{{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
